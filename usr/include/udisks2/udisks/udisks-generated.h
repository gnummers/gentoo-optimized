/*
 * This file is generated by gdbus-codegen, do not modify it.
 *
 * The license of this code is the same as for the D-Bus interface description
 * it was derived from. Note that it links to GLib, so must comply with the
 * LGPL linking clauses.
 */

#ifndef __UDISKS_GENERATED_H__
#define __UDISKS_GENERATED_H__

#include <gio/gio.h>

G_BEGIN_DECLS


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Manager */

#define UDISKS_TYPE_MANAGER (udisks_manager_get_type ())
#define UDISKS_MANAGER(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER, UDisksManager))
#define UDISKS_IS_MANAGER(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER))
#define UDISKS_MANAGER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_MANAGER, UDisksManagerIface))

struct _UDisksManager;
typedef struct _UDisksManager UDisksManager;
typedef struct _UDisksManagerIface UDisksManagerIface;

struct _UDisksManagerIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_enable_modules) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_enable);

  gboolean (*handle_loop_setup) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_fd,
    GVariant *arg_options);

  const gchar * (*get_default_encryption_type) (UDisksManager *object);

  const gchar *const * (*get_supported_encryption_types) (UDisksManager *object);

  const gchar *const * (*get_supported_filesystems) (UDisksManager *object);

  const gchar * (*get_version) (UDisksManager *object);

  gboolean (*handle_mdraid_create) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *arg_blocks,
    const gchar *arg_level,
    const gchar *arg_name,
    guint64 arg_chunk,
    GVariant *arg_options);

  gboolean (*handle_can_check) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type);

  gboolean (*handle_can_format) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type);

  gboolean (*handle_can_repair) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type);

  gboolean (*handle_can_resize) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type);

  gboolean (*handle_get_block_devices) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_resolve_device) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_devspec,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManager, g_object_unref)
#endif

GType udisks_manager_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_manager_interface_info (void);
guint udisks_manager_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_manager_complete_can_format (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *available);

void udisks_manager_complete_can_resize (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *available);

void udisks_manager_complete_can_check (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *available);

void udisks_manager_complete_can_repair (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *available);

void udisks_manager_complete_loop_setup (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    const gchar *resulting_device);

void udisks_manager_complete_mdraid_create (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *resulting_array);

void udisks_manager_complete_enable_modules (
    UDisksManager *object,
    GDBusMethodInvocation *invocation);

void udisks_manager_complete_get_block_devices (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *block_objects);

void udisks_manager_complete_resolve_device (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *devices);



/* D-Bus method calls: */
void udisks_manager_call_can_format (
    UDisksManager *proxy,
    const gchar *arg_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_can_format_finish (
    UDisksManager *proxy,
    GVariant **out_available,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_can_format_sync (
    UDisksManager *proxy,
    const gchar *arg_type,
    GVariant **out_available,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_can_resize (
    UDisksManager *proxy,
    const gchar *arg_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_can_resize_finish (
    UDisksManager *proxy,
    GVariant **out_available,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_can_resize_sync (
    UDisksManager *proxy,
    const gchar *arg_type,
    GVariant **out_available,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_can_check (
    UDisksManager *proxy,
    const gchar *arg_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_can_check_finish (
    UDisksManager *proxy,
    GVariant **out_available,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_can_check_sync (
    UDisksManager *proxy,
    const gchar *arg_type,
    GVariant **out_available,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_can_repair (
    UDisksManager *proxy,
    const gchar *arg_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_can_repair_finish (
    UDisksManager *proxy,
    GVariant **out_available,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_can_repair_sync (
    UDisksManager *proxy,
    const gchar *arg_type,
    GVariant **out_available,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_loop_setup (
    UDisksManager *proxy,
    GVariant *arg_fd,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_loop_setup_finish (
    UDisksManager *proxy,
    gchar **out_resulting_device,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_loop_setup_sync (
    UDisksManager *proxy,
    GVariant *arg_fd,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    gchar **out_resulting_device,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_mdraid_create (
    UDisksManager *proxy,
    const gchar *const *arg_blocks,
    const gchar *arg_level,
    const gchar *arg_name,
    guint64 arg_chunk,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_mdraid_create_finish (
    UDisksManager *proxy,
    gchar **out_resulting_array,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_mdraid_create_sync (
    UDisksManager *proxy,
    const gchar *const *arg_blocks,
    const gchar *arg_level,
    const gchar *arg_name,
    guint64 arg_chunk,
    GVariant *arg_options,
    gchar **out_resulting_array,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_enable_modules (
    UDisksManager *proxy,
    gboolean arg_enable,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_enable_modules_finish (
    UDisksManager *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_enable_modules_sync (
    UDisksManager *proxy,
    gboolean arg_enable,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_get_block_devices (
    UDisksManager *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_get_block_devices_finish (
    UDisksManager *proxy,
    gchar ***out_block_objects,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_get_block_devices_sync (
    UDisksManager *proxy,
    GVariant *arg_options,
    gchar ***out_block_objects,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_resolve_device (
    UDisksManager *proxy,
    GVariant *arg_devspec,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_resolve_device_finish (
    UDisksManager *proxy,
    gchar ***out_devices,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_resolve_device_sync (
    UDisksManager *proxy,
    GVariant *arg_devspec,
    GVariant *arg_options,
    gchar ***out_devices,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_manager_get_version (UDisksManager *object);
gchar *udisks_manager_dup_version (UDisksManager *object);
void udisks_manager_set_version (UDisksManager *object, const gchar *value);

const gchar *const *udisks_manager_get_supported_filesystems (UDisksManager *object);
gchar **udisks_manager_dup_supported_filesystems (UDisksManager *object);
void udisks_manager_set_supported_filesystems (UDisksManager *object, const gchar *const *value);

const gchar *const *udisks_manager_get_supported_encryption_types (UDisksManager *object);
gchar **udisks_manager_dup_supported_encryption_types (UDisksManager *object);
void udisks_manager_set_supported_encryption_types (UDisksManager *object, const gchar *const *value);

const gchar *udisks_manager_get_default_encryption_type (UDisksManager *object);
gchar *udisks_manager_dup_default_encryption_type (UDisksManager *object);
void udisks_manager_set_default_encryption_type (UDisksManager *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_MANAGER_PROXY (udisks_manager_proxy_get_type ())
#define UDISKS_MANAGER_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_PROXY, UDisksManagerProxy))
#define UDISKS_MANAGER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_PROXY, UDisksManagerProxyClass))
#define UDISKS_MANAGER_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_PROXY, UDisksManagerProxyClass))
#define UDISKS_IS_MANAGER_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_PROXY))
#define UDISKS_IS_MANAGER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_PROXY))

typedef struct _UDisksManagerProxy UDisksManagerProxy;
typedef struct _UDisksManagerProxyClass UDisksManagerProxyClass;
typedef struct _UDisksManagerProxyPrivate UDisksManagerProxyPrivate;

struct _UDisksManagerProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksManagerProxyPrivate *priv;
};

struct _UDisksManagerProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_manager_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerProxy, g_object_unref)
#endif

void udisks_manager_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManager *udisks_manager_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManager *udisks_manager_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_manager_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManager *udisks_manager_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManager *udisks_manager_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_MANAGER_SKELETON (udisks_manager_skeleton_get_type ())
#define UDISKS_MANAGER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_SKELETON, UDisksManagerSkeleton))
#define UDISKS_MANAGER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_SKELETON, UDisksManagerSkeletonClass))
#define UDISKS_MANAGER_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_SKELETON, UDisksManagerSkeletonClass))
#define UDISKS_IS_MANAGER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_SKELETON))
#define UDISKS_IS_MANAGER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_SKELETON))

typedef struct _UDisksManagerSkeleton UDisksManagerSkeleton;
typedef struct _UDisksManagerSkeletonClass UDisksManagerSkeletonClass;
typedef struct _UDisksManagerSkeletonPrivate UDisksManagerSkeletonPrivate;

struct _UDisksManagerSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksManagerSkeletonPrivate *priv;
};

struct _UDisksManagerSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_manager_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerSkeleton, g_object_unref)
#endif

UDisksManager *udisks_manager_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Drive */

#define UDISKS_TYPE_DRIVE (udisks_drive_get_type ())
#define UDISKS_DRIVE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE, UDisksDrive))
#define UDISKS_IS_DRIVE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE))
#define UDISKS_DRIVE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_DRIVE, UDisksDriveIface))

struct _UDisksDrive;
typedef struct _UDisksDrive UDisksDrive;
typedef struct _UDisksDriveIface UDisksDriveIface;

struct _UDisksDriveIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_eject) (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_set_configuration) (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_value,
    GVariant *arg_options);

  GVariant * (*get_configuration) (UDisksDrive *object);

  const gchar * (*get_connection_bus) (UDisksDrive *object);

  gboolean  (*get_ejectable) (UDisksDrive *object);

  const gchar * (*get_id) (UDisksDrive *object);

  const gchar * (*get_media) (UDisksDrive *object);

  gboolean  (*get_media_available) (UDisksDrive *object);

  gboolean  (*get_media_change_detected) (UDisksDrive *object);

  const gchar *const * (*get_media_compatibility) (UDisksDrive *object);

  gboolean  (*get_media_removable) (UDisksDrive *object);

  const gchar * (*get_model) (UDisksDrive *object);

  gboolean  (*get_optical) (UDisksDrive *object);

  gboolean  (*get_optical_blank) (UDisksDrive *object);

  guint  (*get_optical_num_audio_tracks) (UDisksDrive *object);

  guint  (*get_optical_num_data_tracks) (UDisksDrive *object);

  guint  (*get_optical_num_sessions) (UDisksDrive *object);

  guint  (*get_optical_num_tracks) (UDisksDrive *object);

  gboolean  (*get_removable) (UDisksDrive *object);

  const gchar * (*get_revision) (UDisksDrive *object);

  gint  (*get_rotation_rate) (UDisksDrive *object);

  const gchar * (*get_seat) (UDisksDrive *object);

  const gchar * (*get_serial) (UDisksDrive *object);

  guint64  (*get_size) (UDisksDrive *object);

  const gchar * (*get_sort_key) (UDisksDrive *object);

  guint64  (*get_time_detected) (UDisksDrive *object);

  guint64  (*get_time_media_detected) (UDisksDrive *object);

  const gchar * (*get_vendor) (UDisksDrive *object);

  const gchar * (*get_wwn) (UDisksDrive *object);

  gboolean (*handle_power_off) (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_can_power_off) (UDisksDrive *object);

  const gchar * (*get_sibling_id) (UDisksDrive *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDrive, g_object_unref)
#endif

GType udisks_drive_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_drive_interface_info (void);
guint udisks_drive_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_drive_complete_eject (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_complete_set_configuration (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_complete_power_off (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_drive_call_eject (
    UDisksDrive *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_call_eject_finish (
    UDisksDrive *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_call_eject_sync (
    UDisksDrive *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_call_set_configuration (
    UDisksDrive *proxy,
    GVariant *arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_call_set_configuration_finish (
    UDisksDrive *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_call_set_configuration_sync (
    UDisksDrive *proxy,
    GVariant *arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_call_power_off (
    UDisksDrive *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_call_power_off_finish (
    UDisksDrive *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_call_power_off_sync (
    UDisksDrive *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_drive_get_vendor (UDisksDrive *object);
gchar *udisks_drive_dup_vendor (UDisksDrive *object);
void udisks_drive_set_vendor (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_model (UDisksDrive *object);
gchar *udisks_drive_dup_model (UDisksDrive *object);
void udisks_drive_set_model (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_revision (UDisksDrive *object);
gchar *udisks_drive_dup_revision (UDisksDrive *object);
void udisks_drive_set_revision (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_serial (UDisksDrive *object);
gchar *udisks_drive_dup_serial (UDisksDrive *object);
void udisks_drive_set_serial (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_wwn (UDisksDrive *object);
gchar *udisks_drive_dup_wwn (UDisksDrive *object);
void udisks_drive_set_wwn (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_id (UDisksDrive *object);
gchar *udisks_drive_dup_id (UDisksDrive *object);
void udisks_drive_set_id (UDisksDrive *object, const gchar *value);

GVariant *udisks_drive_get_configuration (UDisksDrive *object);
GVariant *udisks_drive_dup_configuration (UDisksDrive *object);
void udisks_drive_set_configuration (UDisksDrive *object, GVariant *value);

const gchar *udisks_drive_get_media (UDisksDrive *object);
gchar *udisks_drive_dup_media (UDisksDrive *object);
void udisks_drive_set_media (UDisksDrive *object, const gchar *value);

const gchar *const *udisks_drive_get_media_compatibility (UDisksDrive *object);
gchar **udisks_drive_dup_media_compatibility (UDisksDrive *object);
void udisks_drive_set_media_compatibility (UDisksDrive *object, const gchar *const *value);

gboolean udisks_drive_get_media_removable (UDisksDrive *object);
void udisks_drive_set_media_removable (UDisksDrive *object, gboolean value);

gboolean udisks_drive_get_media_available (UDisksDrive *object);
void udisks_drive_set_media_available (UDisksDrive *object, gboolean value);

gboolean udisks_drive_get_media_change_detected (UDisksDrive *object);
void udisks_drive_set_media_change_detected (UDisksDrive *object, gboolean value);

guint64 udisks_drive_get_size (UDisksDrive *object);
void udisks_drive_set_size (UDisksDrive *object, guint64 value);

guint64 udisks_drive_get_time_detected (UDisksDrive *object);
void udisks_drive_set_time_detected (UDisksDrive *object, guint64 value);

guint64 udisks_drive_get_time_media_detected (UDisksDrive *object);
void udisks_drive_set_time_media_detected (UDisksDrive *object, guint64 value);

gboolean udisks_drive_get_optical (UDisksDrive *object);
void udisks_drive_set_optical (UDisksDrive *object, gboolean value);

gboolean udisks_drive_get_optical_blank (UDisksDrive *object);
void udisks_drive_set_optical_blank (UDisksDrive *object, gboolean value);

guint udisks_drive_get_optical_num_tracks (UDisksDrive *object);
void udisks_drive_set_optical_num_tracks (UDisksDrive *object, guint value);

guint udisks_drive_get_optical_num_audio_tracks (UDisksDrive *object);
void udisks_drive_set_optical_num_audio_tracks (UDisksDrive *object, guint value);

guint udisks_drive_get_optical_num_data_tracks (UDisksDrive *object);
void udisks_drive_set_optical_num_data_tracks (UDisksDrive *object, guint value);

guint udisks_drive_get_optical_num_sessions (UDisksDrive *object);
void udisks_drive_set_optical_num_sessions (UDisksDrive *object, guint value);

gint udisks_drive_get_rotation_rate (UDisksDrive *object);
void udisks_drive_set_rotation_rate (UDisksDrive *object, gint value);

const gchar *udisks_drive_get_connection_bus (UDisksDrive *object);
gchar *udisks_drive_dup_connection_bus (UDisksDrive *object);
void udisks_drive_set_connection_bus (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_seat (UDisksDrive *object);
gchar *udisks_drive_dup_seat (UDisksDrive *object);
void udisks_drive_set_seat (UDisksDrive *object, const gchar *value);

gboolean udisks_drive_get_removable (UDisksDrive *object);
void udisks_drive_set_removable (UDisksDrive *object, gboolean value);

gboolean udisks_drive_get_ejectable (UDisksDrive *object);
void udisks_drive_set_ejectable (UDisksDrive *object, gboolean value);

const gchar *udisks_drive_get_sort_key (UDisksDrive *object);
gchar *udisks_drive_dup_sort_key (UDisksDrive *object);
void udisks_drive_set_sort_key (UDisksDrive *object, const gchar *value);

gboolean udisks_drive_get_can_power_off (UDisksDrive *object);
void udisks_drive_set_can_power_off (UDisksDrive *object, gboolean value);

const gchar *udisks_drive_get_sibling_id (UDisksDrive *object);
gchar *udisks_drive_dup_sibling_id (UDisksDrive *object);
void udisks_drive_set_sibling_id (UDisksDrive *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_DRIVE_PROXY (udisks_drive_proxy_get_type ())
#define UDISKS_DRIVE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_PROXY, UDisksDriveProxy))
#define UDISKS_DRIVE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_DRIVE_PROXY, UDisksDriveProxyClass))
#define UDISKS_DRIVE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_DRIVE_PROXY, UDisksDriveProxyClass))
#define UDISKS_IS_DRIVE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_PROXY))
#define UDISKS_IS_DRIVE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_DRIVE_PROXY))

typedef struct _UDisksDriveProxy UDisksDriveProxy;
typedef struct _UDisksDriveProxyClass UDisksDriveProxyClass;
typedef struct _UDisksDriveProxyPrivate UDisksDriveProxyPrivate;

struct _UDisksDriveProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksDriveProxyPrivate *priv;
};

struct _UDisksDriveProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_drive_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveProxy, g_object_unref)
#endif

void udisks_drive_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksDrive *udisks_drive_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksDrive *udisks_drive_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_drive_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksDrive *udisks_drive_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksDrive *udisks_drive_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_DRIVE_SKELETON (udisks_drive_skeleton_get_type ())
#define UDISKS_DRIVE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_SKELETON, UDisksDriveSkeleton))
#define UDISKS_DRIVE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_DRIVE_SKELETON, UDisksDriveSkeletonClass))
#define UDISKS_DRIVE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_DRIVE_SKELETON, UDisksDriveSkeletonClass))
#define UDISKS_IS_DRIVE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_SKELETON))
#define UDISKS_IS_DRIVE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_DRIVE_SKELETON))

typedef struct _UDisksDriveSkeleton UDisksDriveSkeleton;
typedef struct _UDisksDriveSkeletonClass UDisksDriveSkeletonClass;
typedef struct _UDisksDriveSkeletonPrivate UDisksDriveSkeletonPrivate;

struct _UDisksDriveSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksDriveSkeletonPrivate *priv;
};

struct _UDisksDriveSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_drive_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveSkeleton, g_object_unref)
#endif

UDisksDrive *udisks_drive_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Drive.Ata */

#define UDISKS_TYPE_DRIVE_ATA (udisks_drive_ata_get_type ())
#define UDISKS_DRIVE_ATA(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_ATA, UDisksDriveAta))
#define UDISKS_IS_DRIVE_ATA(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_ATA))
#define UDISKS_DRIVE_ATA_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_DRIVE_ATA, UDisksDriveAtaIface))

struct _UDisksDriveAta;
typedef struct _UDisksDriveAta UDisksDriveAta;
typedef struct _UDisksDriveAtaIface UDisksDriveAtaIface;

struct _UDisksDriveAtaIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_pm_get_state) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_pm_standby) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_pm_wakeup) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_security_erase_unit) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_smart_get_attributes) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_smart_selftest_abort) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_smart_selftest_start) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type,
    GVariant *arg_options);

  gboolean (*handle_smart_update) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_aam_enabled) (UDisksDriveAta *object);

  gboolean  (*get_aam_supported) (UDisksDriveAta *object);

  gint  (*get_aam_vendor_recommended_value) (UDisksDriveAta *object);

  gboolean  (*get_apm_enabled) (UDisksDriveAta *object);

  gboolean  (*get_apm_supported) (UDisksDriveAta *object);

  gboolean  (*get_pm_enabled) (UDisksDriveAta *object);

  gboolean  (*get_pm_supported) (UDisksDriveAta *object);

  gint  (*get_security_enhanced_erase_unit_minutes) (UDisksDriveAta *object);

  gint  (*get_security_erase_unit_minutes) (UDisksDriveAta *object);

  gboolean  (*get_security_frozen) (UDisksDriveAta *object);

  gboolean  (*get_smart_enabled) (UDisksDriveAta *object);

  gboolean  (*get_smart_failing) (UDisksDriveAta *object);

  gint  (*get_smart_num_attributes_failed_in_the_past) (UDisksDriveAta *object);

  gint  (*get_smart_num_attributes_failing) (UDisksDriveAta *object);

  gint64  (*get_smart_num_bad_sectors) (UDisksDriveAta *object);

  guint64  (*get_smart_power_on_seconds) (UDisksDriveAta *object);

  gint  (*get_smart_selftest_percent_remaining) (UDisksDriveAta *object);

  const gchar * (*get_smart_selftest_status) (UDisksDriveAta *object);

  gboolean  (*get_smart_supported) (UDisksDriveAta *object);

  gdouble  (*get_smart_temperature) (UDisksDriveAta *object);

  guint64  (*get_smart_updated) (UDisksDriveAta *object);

  gboolean (*handle_smart_set_enabled) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_value,
    GVariant *arg_options);

  gboolean  (*get_write_cache_enabled) (UDisksDriveAta *object);

  gboolean  (*get_write_cache_supported) (UDisksDriveAta *object);

  gboolean  (*get_read_lookahead_enabled) (UDisksDriveAta *object);

  gboolean  (*get_read_lookahead_supported) (UDisksDriveAta *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveAta, g_object_unref)
#endif

GType udisks_drive_ata_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_drive_ata_interface_info (void);
guint udisks_drive_ata_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_drive_ata_complete_smart_update (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_smart_get_attributes (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *attributes);

void udisks_drive_ata_complete_smart_selftest_start (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_smart_selftest_abort (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_smart_set_enabled (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_pm_get_state (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    guchar state);

void udisks_drive_ata_complete_pm_standby (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_pm_wakeup (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_security_erase_unit (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_drive_ata_call_smart_update (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_update_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_update_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_smart_get_attributes (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_get_attributes_finish (
    UDisksDriveAta *proxy,
    GVariant **out_attributes,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_get_attributes_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GVariant **out_attributes,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_smart_selftest_start (
    UDisksDriveAta *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_selftest_start_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_selftest_start_sync (
    UDisksDriveAta *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_smart_selftest_abort (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_selftest_abort_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_selftest_abort_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_smart_set_enabled (
    UDisksDriveAta *proxy,
    gboolean arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_set_enabled_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_set_enabled_sync (
    UDisksDriveAta *proxy,
    gboolean arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_pm_get_state (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_pm_get_state_finish (
    UDisksDriveAta *proxy,
    guchar *out_state,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_pm_get_state_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    guchar *out_state,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_pm_standby (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_pm_standby_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_pm_standby_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_pm_wakeup (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_pm_wakeup_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_pm_wakeup_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_security_erase_unit (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_security_erase_unit_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_security_erase_unit_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gboolean udisks_drive_ata_get_smart_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_smart_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_enabled (UDisksDriveAta *object, gboolean value);

guint64 udisks_drive_ata_get_smart_updated (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_updated (UDisksDriveAta *object, guint64 value);

gboolean udisks_drive_ata_get_smart_failing (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_failing (UDisksDriveAta *object, gboolean value);

guint64 udisks_drive_ata_get_smart_power_on_seconds (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_power_on_seconds (UDisksDriveAta *object, guint64 value);

gdouble udisks_drive_ata_get_smart_temperature (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_temperature (UDisksDriveAta *object, gdouble value);

gint udisks_drive_ata_get_smart_num_attributes_failing (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_num_attributes_failing (UDisksDriveAta *object, gint value);

gint udisks_drive_ata_get_smart_num_attributes_failed_in_the_past (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_num_attributes_failed_in_the_past (UDisksDriveAta *object, gint value);

gint64 udisks_drive_ata_get_smart_num_bad_sectors (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_num_bad_sectors (UDisksDriveAta *object, gint64 value);

const gchar *udisks_drive_ata_get_smart_selftest_status (UDisksDriveAta *object);
gchar *udisks_drive_ata_dup_smart_selftest_status (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_selftest_status (UDisksDriveAta *object, const gchar *value);

gint udisks_drive_ata_get_smart_selftest_percent_remaining (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_selftest_percent_remaining (UDisksDriveAta *object, gint value);

gboolean udisks_drive_ata_get_pm_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_pm_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_pm_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_pm_enabled (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_apm_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_apm_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_apm_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_apm_enabled (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_aam_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_aam_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_aam_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_aam_enabled (UDisksDriveAta *object, gboolean value);

gint udisks_drive_ata_get_aam_vendor_recommended_value (UDisksDriveAta *object);
void udisks_drive_ata_set_aam_vendor_recommended_value (UDisksDriveAta *object, gint value);

gboolean udisks_drive_ata_get_write_cache_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_write_cache_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_write_cache_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_write_cache_enabled (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_read_lookahead_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_read_lookahead_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_read_lookahead_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_read_lookahead_enabled (UDisksDriveAta *object, gboolean value);

gint udisks_drive_ata_get_security_erase_unit_minutes (UDisksDriveAta *object);
void udisks_drive_ata_set_security_erase_unit_minutes (UDisksDriveAta *object, gint value);

gint udisks_drive_ata_get_security_enhanced_erase_unit_minutes (UDisksDriveAta *object);
void udisks_drive_ata_set_security_enhanced_erase_unit_minutes (UDisksDriveAta *object, gint value);

gboolean udisks_drive_ata_get_security_frozen (UDisksDriveAta *object);
void udisks_drive_ata_set_security_frozen (UDisksDriveAta *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_DRIVE_ATA_PROXY (udisks_drive_ata_proxy_get_type ())
#define UDISKS_DRIVE_ATA_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_ATA_PROXY, UDisksDriveAtaProxy))
#define UDISKS_DRIVE_ATA_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_DRIVE_ATA_PROXY, UDisksDriveAtaProxyClass))
#define UDISKS_DRIVE_ATA_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_DRIVE_ATA_PROXY, UDisksDriveAtaProxyClass))
#define UDISKS_IS_DRIVE_ATA_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_ATA_PROXY))
#define UDISKS_IS_DRIVE_ATA_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_DRIVE_ATA_PROXY))

typedef struct _UDisksDriveAtaProxy UDisksDriveAtaProxy;
typedef struct _UDisksDriveAtaProxyClass UDisksDriveAtaProxyClass;
typedef struct _UDisksDriveAtaProxyPrivate UDisksDriveAtaProxyPrivate;

struct _UDisksDriveAtaProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksDriveAtaProxyPrivate *priv;
};

struct _UDisksDriveAtaProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_drive_ata_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveAtaProxy, g_object_unref)
#endif

void udisks_drive_ata_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksDriveAta *udisks_drive_ata_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksDriveAta *udisks_drive_ata_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_drive_ata_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksDriveAta *udisks_drive_ata_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksDriveAta *udisks_drive_ata_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_DRIVE_ATA_SKELETON (udisks_drive_ata_skeleton_get_type ())
#define UDISKS_DRIVE_ATA_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_ATA_SKELETON, UDisksDriveAtaSkeleton))
#define UDISKS_DRIVE_ATA_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_DRIVE_ATA_SKELETON, UDisksDriveAtaSkeletonClass))
#define UDISKS_DRIVE_ATA_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_DRIVE_ATA_SKELETON, UDisksDriveAtaSkeletonClass))
#define UDISKS_IS_DRIVE_ATA_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_ATA_SKELETON))
#define UDISKS_IS_DRIVE_ATA_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_DRIVE_ATA_SKELETON))

typedef struct _UDisksDriveAtaSkeleton UDisksDriveAtaSkeleton;
typedef struct _UDisksDriveAtaSkeletonClass UDisksDriveAtaSkeletonClass;
typedef struct _UDisksDriveAtaSkeletonPrivate UDisksDriveAtaSkeletonPrivate;

struct _UDisksDriveAtaSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksDriveAtaSkeletonPrivate *priv;
};

struct _UDisksDriveAtaSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_drive_ata_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveAtaSkeleton, g_object_unref)
#endif

UDisksDriveAta *udisks_drive_ata_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Block */

#define UDISKS_TYPE_BLOCK (udisks_block_get_type ())
#define UDISKS_BLOCK(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK, UDisksBlock))
#define UDISKS_IS_BLOCK(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK))
#define UDISKS_BLOCK_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_BLOCK, UDisksBlockIface))

struct _UDisksBlock;
typedef struct _UDisksBlock UDisksBlock;
typedef struct _UDisksBlockIface UDisksBlockIface;

struct _UDisksBlockIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_add_configuration_item) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_item,
    GVariant *arg_options);

  gboolean (*handle_format) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type,
    GVariant *arg_options);

  gboolean (*handle_get_secret_configuration) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_open_for_backup) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_options);

  gboolean (*handle_open_for_benchmark) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_options);

  gboolean (*handle_open_for_restore) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_options);

  gboolean (*handle_remove_configuration_item) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_item,
    GVariant *arg_options);

  gboolean (*handle_rescan) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_update_configuration_item) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_old_item,
    GVariant *arg_new_item,
    GVariant *arg_options);

  GVariant * (*get_configuration) (UDisksBlock *object);

  const gchar * (*get_crypto_backing_device) (UDisksBlock *object);

  const gchar * (*get_device) (UDisksBlock *object);

  guint64  (*get_device_number) (UDisksBlock *object);

  const gchar * (*get_drive) (UDisksBlock *object);

  gboolean  (*get_hint_auto) (UDisksBlock *object);

  const gchar * (*get_hint_icon_name) (UDisksBlock *object);

  gboolean  (*get_hint_ignore) (UDisksBlock *object);

  const gchar * (*get_hint_name) (UDisksBlock *object);

  gboolean  (*get_hint_partitionable) (UDisksBlock *object);

  gboolean  (*get_hint_system) (UDisksBlock *object);

  const gchar * (*get_id_label) (UDisksBlock *object);

  const gchar * (*get_id_type) (UDisksBlock *object);

  const gchar * (*get_id_usage) (UDisksBlock *object);

  const gchar * (*get_id_uuid) (UDisksBlock *object);

  const gchar * (*get_id_version) (UDisksBlock *object);

  const gchar * (*get_preferred_device) (UDisksBlock *object);

  gboolean  (*get_read_only) (UDisksBlock *object);

  guint64  (*get_size) (UDisksBlock *object);

  const gchar *const * (*get_symlinks) (UDisksBlock *object);

  const gchar *const * (*get_userspace_mount_options) (UDisksBlock *object);

  const gchar * (*get_hint_symbolic_icon_name) (UDisksBlock *object);

  const gchar * (*get_id) (UDisksBlock *object);

  const gchar * (*get_mdraid) (UDisksBlock *object);

  const gchar * (*get_mdraid_member) (UDisksBlock *object);

  gboolean (*handle_open_device) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    const gchar *arg_mode,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlock, g_object_unref)
#endif

GType udisks_block_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_block_interface_info (void);
guint udisks_block_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_block_complete_add_configuration_item (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);

void udisks_block_complete_remove_configuration_item (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);

void udisks_block_complete_update_configuration_item (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);

void udisks_block_complete_get_secret_configuration (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *configuration);

void udisks_block_complete_format (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);

void udisks_block_complete_open_for_backup (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *fd);

void udisks_block_complete_open_for_restore (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *fd);

void udisks_block_complete_open_for_benchmark (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *fd);

void udisks_block_complete_open_device (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *fd);

void udisks_block_complete_rescan (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_block_call_add_configuration_item (
    UDisksBlock *proxy,
    GVariant *arg_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_add_configuration_item_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_add_configuration_item_sync (
    UDisksBlock *proxy,
    GVariant *arg_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_remove_configuration_item (
    UDisksBlock *proxy,
    GVariant *arg_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_remove_configuration_item_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_remove_configuration_item_sync (
    UDisksBlock *proxy,
    GVariant *arg_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_update_configuration_item (
    UDisksBlock *proxy,
    GVariant *arg_old_item,
    GVariant *arg_new_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_update_configuration_item_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_update_configuration_item_sync (
    UDisksBlock *proxy,
    GVariant *arg_old_item,
    GVariant *arg_new_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_get_secret_configuration (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_get_secret_configuration_finish (
    UDisksBlock *proxy,
    GVariant **out_configuration,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_get_secret_configuration_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GVariant **out_configuration,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_format (
    UDisksBlock *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_format_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_format_sync (
    UDisksBlock *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_open_for_backup (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_open_for_backup_finish (
    UDisksBlock *proxy,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_open_for_backup_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_open_for_restore (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_open_for_restore_finish (
    UDisksBlock *proxy,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_open_for_restore_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_open_for_benchmark (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_open_for_benchmark_finish (
    UDisksBlock *proxy,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_open_for_benchmark_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_open_device (
    UDisksBlock *proxy,
    const gchar *arg_mode,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_open_device_finish (
    UDisksBlock *proxy,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_open_device_sync (
    UDisksBlock *proxy,
    const gchar *arg_mode,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_rescan (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_rescan_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_rescan_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_block_get_device (UDisksBlock *object);
gchar *udisks_block_dup_device (UDisksBlock *object);
void udisks_block_set_device (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_preferred_device (UDisksBlock *object);
gchar *udisks_block_dup_preferred_device (UDisksBlock *object);
void udisks_block_set_preferred_device (UDisksBlock *object, const gchar *value);

const gchar *const *udisks_block_get_symlinks (UDisksBlock *object);
gchar **udisks_block_dup_symlinks (UDisksBlock *object);
void udisks_block_set_symlinks (UDisksBlock *object, const gchar *const *value);

guint64 udisks_block_get_device_number (UDisksBlock *object);
void udisks_block_set_device_number (UDisksBlock *object, guint64 value);

const gchar *udisks_block_get_id (UDisksBlock *object);
gchar *udisks_block_dup_id (UDisksBlock *object);
void udisks_block_set_id (UDisksBlock *object, const gchar *value);

guint64 udisks_block_get_size (UDisksBlock *object);
void udisks_block_set_size (UDisksBlock *object, guint64 value);

gboolean udisks_block_get_read_only (UDisksBlock *object);
void udisks_block_set_read_only (UDisksBlock *object, gboolean value);

const gchar *udisks_block_get_drive (UDisksBlock *object);
gchar *udisks_block_dup_drive (UDisksBlock *object);
void udisks_block_set_drive (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_mdraid (UDisksBlock *object);
gchar *udisks_block_dup_mdraid (UDisksBlock *object);
void udisks_block_set_mdraid (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_mdraid_member (UDisksBlock *object);
gchar *udisks_block_dup_mdraid_member (UDisksBlock *object);
void udisks_block_set_mdraid_member (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_usage (UDisksBlock *object);
gchar *udisks_block_dup_id_usage (UDisksBlock *object);
void udisks_block_set_id_usage (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_type (UDisksBlock *object);
gchar *udisks_block_dup_id_type (UDisksBlock *object);
void udisks_block_set_id_type (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_version (UDisksBlock *object);
gchar *udisks_block_dup_id_version (UDisksBlock *object);
void udisks_block_set_id_version (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_label (UDisksBlock *object);
gchar *udisks_block_dup_id_label (UDisksBlock *object);
void udisks_block_set_id_label (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_uuid (UDisksBlock *object);
gchar *udisks_block_dup_id_uuid (UDisksBlock *object);
void udisks_block_set_id_uuid (UDisksBlock *object, const gchar *value);

GVariant *udisks_block_get_configuration (UDisksBlock *object);
GVariant *udisks_block_dup_configuration (UDisksBlock *object);
void udisks_block_set_configuration (UDisksBlock *object, GVariant *value);

const gchar *udisks_block_get_crypto_backing_device (UDisksBlock *object);
gchar *udisks_block_dup_crypto_backing_device (UDisksBlock *object);
void udisks_block_set_crypto_backing_device (UDisksBlock *object, const gchar *value);

gboolean udisks_block_get_hint_partitionable (UDisksBlock *object);
void udisks_block_set_hint_partitionable (UDisksBlock *object, gboolean value);

gboolean udisks_block_get_hint_system (UDisksBlock *object);
void udisks_block_set_hint_system (UDisksBlock *object, gboolean value);

gboolean udisks_block_get_hint_ignore (UDisksBlock *object);
void udisks_block_set_hint_ignore (UDisksBlock *object, gboolean value);

gboolean udisks_block_get_hint_auto (UDisksBlock *object);
void udisks_block_set_hint_auto (UDisksBlock *object, gboolean value);

const gchar *udisks_block_get_hint_name (UDisksBlock *object);
gchar *udisks_block_dup_hint_name (UDisksBlock *object);
void udisks_block_set_hint_name (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_hint_icon_name (UDisksBlock *object);
gchar *udisks_block_dup_hint_icon_name (UDisksBlock *object);
void udisks_block_set_hint_icon_name (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_hint_symbolic_icon_name (UDisksBlock *object);
gchar *udisks_block_dup_hint_symbolic_icon_name (UDisksBlock *object);
void udisks_block_set_hint_symbolic_icon_name (UDisksBlock *object, const gchar *value);

const gchar *const *udisks_block_get_userspace_mount_options (UDisksBlock *object);
gchar **udisks_block_dup_userspace_mount_options (UDisksBlock *object);
void udisks_block_set_userspace_mount_options (UDisksBlock *object, const gchar *const *value);


/* ---- */

#define UDISKS_TYPE_BLOCK_PROXY (udisks_block_proxy_get_type ())
#define UDISKS_BLOCK_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_PROXY, UDisksBlockProxy))
#define UDISKS_BLOCK_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_PROXY, UDisksBlockProxyClass))
#define UDISKS_BLOCK_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_PROXY, UDisksBlockProxyClass))
#define UDISKS_IS_BLOCK_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_PROXY))
#define UDISKS_IS_BLOCK_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_PROXY))

typedef struct _UDisksBlockProxy UDisksBlockProxy;
typedef struct _UDisksBlockProxyClass UDisksBlockProxyClass;
typedef struct _UDisksBlockProxyPrivate UDisksBlockProxyPrivate;

struct _UDisksBlockProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksBlockProxyPrivate *priv;
};

struct _UDisksBlockProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_block_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockProxy, g_object_unref)
#endif

void udisks_block_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlock *udisks_block_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlock *udisks_block_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_block_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlock *udisks_block_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlock *udisks_block_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_BLOCK_SKELETON (udisks_block_skeleton_get_type ())
#define UDISKS_BLOCK_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_SKELETON, UDisksBlockSkeleton))
#define UDISKS_BLOCK_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_SKELETON, UDisksBlockSkeletonClass))
#define UDISKS_BLOCK_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_SKELETON, UDisksBlockSkeletonClass))
#define UDISKS_IS_BLOCK_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_SKELETON))
#define UDISKS_IS_BLOCK_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_SKELETON))

typedef struct _UDisksBlockSkeleton UDisksBlockSkeleton;
typedef struct _UDisksBlockSkeletonClass UDisksBlockSkeletonClass;
typedef struct _UDisksBlockSkeletonPrivate UDisksBlockSkeletonPrivate;

struct _UDisksBlockSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksBlockSkeletonPrivate *priv;
};

struct _UDisksBlockSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_block_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockSkeleton, g_object_unref)
#endif

UDisksBlock *udisks_block_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.PartitionTable */

#define UDISKS_TYPE_PARTITION_TABLE (udisks_partition_table_get_type ())
#define UDISKS_PARTITION_TABLE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_TABLE, UDisksPartitionTable))
#define UDISKS_IS_PARTITION_TABLE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_TABLE))
#define UDISKS_PARTITION_TABLE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_PARTITION_TABLE, UDisksPartitionTableIface))

struct _UDisksPartitionTable;
typedef struct _UDisksPartitionTable UDisksPartitionTable;
typedef struct _UDisksPartitionTableIface UDisksPartitionTableIface;

struct _UDisksPartitionTableIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_create_partition) (
    UDisksPartitionTable *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options);

  gboolean (*handle_create_partition_and_format) (
    UDisksPartitionTable *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    const gchar *arg_format_type,
    GVariant *arg_format_options);

  const gchar *const * (*get_partitions) (UDisksPartitionTable *object);

  const gchar * (*get_type_) (UDisksPartitionTable *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionTable, g_object_unref)
#endif

GType udisks_partition_table_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_partition_table_interface_info (void);
guint udisks_partition_table_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_partition_table_complete_create_partition (
    UDisksPartitionTable *object,
    GDBusMethodInvocation *invocation,
    const gchar *created_partition);

void udisks_partition_table_complete_create_partition_and_format (
    UDisksPartitionTable *object,
    GDBusMethodInvocation *invocation,
    const gchar *created_partition);



/* D-Bus method calls: */
void udisks_partition_table_call_create_partition (
    UDisksPartitionTable *proxy,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_table_call_create_partition_finish (
    UDisksPartitionTable *proxy,
    gchar **out_created_partition,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_table_call_create_partition_sync (
    UDisksPartitionTable *proxy,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    gchar **out_created_partition,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_table_call_create_partition_and_format (
    UDisksPartitionTable *proxy,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    const gchar *arg_format_type,
    GVariant *arg_format_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_table_call_create_partition_and_format_finish (
    UDisksPartitionTable *proxy,
    gchar **out_created_partition,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_table_call_create_partition_and_format_sync (
    UDisksPartitionTable *proxy,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    const gchar *arg_format_type,
    GVariant *arg_format_options,
    gchar **out_created_partition,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *const *udisks_partition_table_get_partitions (UDisksPartitionTable *object);
gchar **udisks_partition_table_dup_partitions (UDisksPartitionTable *object);
void udisks_partition_table_set_partitions (UDisksPartitionTable *object, const gchar *const *value);

const gchar *udisks_partition_table_get_type_ (UDisksPartitionTable *object);
gchar *udisks_partition_table_dup_type_ (UDisksPartitionTable *object);
void udisks_partition_table_set_type_ (UDisksPartitionTable *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_PARTITION_TABLE_PROXY (udisks_partition_table_proxy_get_type ())
#define UDISKS_PARTITION_TABLE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_TABLE_PROXY, UDisksPartitionTableProxy))
#define UDISKS_PARTITION_TABLE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PARTITION_TABLE_PROXY, UDisksPartitionTableProxyClass))
#define UDISKS_PARTITION_TABLE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PARTITION_TABLE_PROXY, UDisksPartitionTableProxyClass))
#define UDISKS_IS_PARTITION_TABLE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_TABLE_PROXY))
#define UDISKS_IS_PARTITION_TABLE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PARTITION_TABLE_PROXY))

typedef struct _UDisksPartitionTableProxy UDisksPartitionTableProxy;
typedef struct _UDisksPartitionTableProxyClass UDisksPartitionTableProxyClass;
typedef struct _UDisksPartitionTableProxyPrivate UDisksPartitionTableProxyPrivate;

struct _UDisksPartitionTableProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksPartitionTableProxyPrivate *priv;
};

struct _UDisksPartitionTableProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_partition_table_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionTableProxy, g_object_unref)
#endif

void udisks_partition_table_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPartitionTable *udisks_partition_table_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPartitionTable *udisks_partition_table_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_partition_table_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPartitionTable *udisks_partition_table_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPartitionTable *udisks_partition_table_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_PARTITION_TABLE_SKELETON (udisks_partition_table_skeleton_get_type ())
#define UDISKS_PARTITION_TABLE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_TABLE_SKELETON, UDisksPartitionTableSkeleton))
#define UDISKS_PARTITION_TABLE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PARTITION_TABLE_SKELETON, UDisksPartitionTableSkeletonClass))
#define UDISKS_PARTITION_TABLE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PARTITION_TABLE_SKELETON, UDisksPartitionTableSkeletonClass))
#define UDISKS_IS_PARTITION_TABLE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_TABLE_SKELETON))
#define UDISKS_IS_PARTITION_TABLE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PARTITION_TABLE_SKELETON))

typedef struct _UDisksPartitionTableSkeleton UDisksPartitionTableSkeleton;
typedef struct _UDisksPartitionTableSkeletonClass UDisksPartitionTableSkeletonClass;
typedef struct _UDisksPartitionTableSkeletonPrivate UDisksPartitionTableSkeletonPrivate;

struct _UDisksPartitionTableSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksPartitionTableSkeletonPrivate *priv;
};

struct _UDisksPartitionTableSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_partition_table_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionTableSkeleton, g_object_unref)
#endif

UDisksPartitionTable *udisks_partition_table_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Partition */

#define UDISKS_TYPE_PARTITION (udisks_partition_get_type ())
#define UDISKS_PARTITION(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION, UDisksPartition))
#define UDISKS_IS_PARTITION(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION))
#define UDISKS_PARTITION_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_PARTITION, UDisksPartitionIface))

struct _UDisksPartition;
typedef struct _UDisksPartition UDisksPartition;
typedef struct _UDisksPartitionIface UDisksPartitionIface;

struct _UDisksPartitionIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_delete) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_resize) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean (*handle_set_flags) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_flags,
    GVariant *arg_options);

  gboolean (*handle_set_name) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    GVariant *arg_options);

  gboolean (*handle_set_type) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type,
    GVariant *arg_options);

  guint64  (*get_flags) (UDisksPartition *object);

  gboolean  (*get_is_contained) (UDisksPartition *object);

  gboolean  (*get_is_container) (UDisksPartition *object);

  const gchar * (*get_name) (UDisksPartition *object);

  guint  (*get_number) (UDisksPartition *object);

  guint64  (*get_offset) (UDisksPartition *object);

  guint64  (*get_size) (UDisksPartition *object);

  const gchar * (*get_table) (UDisksPartition *object);

  const gchar * (*get_type_) (UDisksPartition *object);

  const gchar * (*get_uuid) (UDisksPartition *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartition, g_object_unref)
#endif

GType udisks_partition_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_partition_interface_info (void);
guint udisks_partition_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_partition_complete_set_type (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);

void udisks_partition_complete_set_name (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);

void udisks_partition_complete_set_flags (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);

void udisks_partition_complete_resize (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);

void udisks_partition_complete_delete (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_partition_call_set_type (
    UDisksPartition *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_set_type_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_set_type_sync (
    UDisksPartition *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_call_set_name (
    UDisksPartition *proxy,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_set_name_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_set_name_sync (
    UDisksPartition *proxy,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_call_set_flags (
    UDisksPartition *proxy,
    guint64 arg_flags,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_set_flags_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_set_flags_sync (
    UDisksPartition *proxy,
    guint64 arg_flags,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_call_resize (
    UDisksPartition *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_resize_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_resize_sync (
    UDisksPartition *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_call_delete (
    UDisksPartition *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_delete_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_delete_sync (
    UDisksPartition *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
guint udisks_partition_get_number (UDisksPartition *object);
void udisks_partition_set_number (UDisksPartition *object, guint value);

const gchar *udisks_partition_get_type_ (UDisksPartition *object);
gchar *udisks_partition_dup_type_ (UDisksPartition *object);
void udisks_partition_set_type_ (UDisksPartition *object, const gchar *value);

guint64 udisks_partition_get_flags (UDisksPartition *object);
void udisks_partition_set_flags (UDisksPartition *object, guint64 value);

guint64 udisks_partition_get_offset (UDisksPartition *object);
void udisks_partition_set_offset (UDisksPartition *object, guint64 value);

guint64 udisks_partition_get_size (UDisksPartition *object);
void udisks_partition_set_size (UDisksPartition *object, guint64 value);

const gchar *udisks_partition_get_name (UDisksPartition *object);
gchar *udisks_partition_dup_name (UDisksPartition *object);
void udisks_partition_set_name (UDisksPartition *object, const gchar *value);

const gchar *udisks_partition_get_uuid (UDisksPartition *object);
gchar *udisks_partition_dup_uuid (UDisksPartition *object);
void udisks_partition_set_uuid (UDisksPartition *object, const gchar *value);

const gchar *udisks_partition_get_table (UDisksPartition *object);
gchar *udisks_partition_dup_table (UDisksPartition *object);
void udisks_partition_set_table (UDisksPartition *object, const gchar *value);

gboolean udisks_partition_get_is_container (UDisksPartition *object);
void udisks_partition_set_is_container (UDisksPartition *object, gboolean value);

gboolean udisks_partition_get_is_contained (UDisksPartition *object);
void udisks_partition_set_is_contained (UDisksPartition *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_PARTITION_PROXY (udisks_partition_proxy_get_type ())
#define UDISKS_PARTITION_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_PROXY, UDisksPartitionProxy))
#define UDISKS_PARTITION_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PARTITION_PROXY, UDisksPartitionProxyClass))
#define UDISKS_PARTITION_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PARTITION_PROXY, UDisksPartitionProxyClass))
#define UDISKS_IS_PARTITION_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_PROXY))
#define UDISKS_IS_PARTITION_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PARTITION_PROXY))

typedef struct _UDisksPartitionProxy UDisksPartitionProxy;
typedef struct _UDisksPartitionProxyClass UDisksPartitionProxyClass;
typedef struct _UDisksPartitionProxyPrivate UDisksPartitionProxyPrivate;

struct _UDisksPartitionProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksPartitionProxyPrivate *priv;
};

struct _UDisksPartitionProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_partition_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionProxy, g_object_unref)
#endif

void udisks_partition_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPartition *udisks_partition_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPartition *udisks_partition_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_partition_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPartition *udisks_partition_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPartition *udisks_partition_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_PARTITION_SKELETON (udisks_partition_skeleton_get_type ())
#define UDISKS_PARTITION_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_SKELETON, UDisksPartitionSkeleton))
#define UDISKS_PARTITION_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PARTITION_SKELETON, UDisksPartitionSkeletonClass))
#define UDISKS_PARTITION_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PARTITION_SKELETON, UDisksPartitionSkeletonClass))
#define UDISKS_IS_PARTITION_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_SKELETON))
#define UDISKS_IS_PARTITION_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PARTITION_SKELETON))

typedef struct _UDisksPartitionSkeleton UDisksPartitionSkeleton;
typedef struct _UDisksPartitionSkeletonClass UDisksPartitionSkeletonClass;
typedef struct _UDisksPartitionSkeletonPrivate UDisksPartitionSkeletonPrivate;

struct _UDisksPartitionSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksPartitionSkeletonPrivate *priv;
};

struct _UDisksPartitionSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_partition_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionSkeleton, g_object_unref)
#endif

UDisksPartition *udisks_partition_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Filesystem */

#define UDISKS_TYPE_FILESYSTEM (udisks_filesystem_get_type ())
#define UDISKS_FILESYSTEM(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM, UDisksFilesystem))
#define UDISKS_IS_FILESYSTEM(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM))
#define UDISKS_FILESYSTEM_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_FILESYSTEM, UDisksFilesystemIface))

struct _UDisksFilesystem;
typedef struct _UDisksFilesystem UDisksFilesystem;
typedef struct _UDisksFilesystemIface UDisksFilesystemIface;

struct _UDisksFilesystemIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_mount) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_set_label) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_label,
    GVariant *arg_options);

  gboolean (*handle_unmount) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  const gchar *const * (*get_mount_points) (UDisksFilesystem *object);

  guint64  (*get_size) (UDisksFilesystem *object);

  gboolean (*handle_check) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_repair) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_resize) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean (*handle_take_ownership) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystem, g_object_unref)
#endif

GType udisks_filesystem_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_filesystem_interface_info (void);
guint udisks_filesystem_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_filesystem_complete_set_label (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_complete_mount (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    const gchar *mount_path);

void udisks_filesystem_complete_unmount (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_complete_resize (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_complete_check (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    gboolean consistent);

void udisks_filesystem_complete_repair (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    gboolean repaired);

void udisks_filesystem_complete_take_ownership (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_filesystem_call_set_label (
    UDisksFilesystem *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_set_label_finish (
    UDisksFilesystem *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_set_label_sync (
    UDisksFilesystem *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_mount (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_mount_finish (
    UDisksFilesystem *proxy,
    gchar **out_mount_path,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_mount_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    gchar **out_mount_path,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_unmount (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_unmount_finish (
    UDisksFilesystem *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_unmount_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_resize (
    UDisksFilesystem *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_resize_finish (
    UDisksFilesystem *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_resize_sync (
    UDisksFilesystem *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_check (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_check_finish (
    UDisksFilesystem *proxy,
    gboolean *out_consistent,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_check_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    gboolean *out_consistent,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_repair (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_repair_finish (
    UDisksFilesystem *proxy,
    gboolean *out_repaired,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_repair_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    gboolean *out_repaired,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_take_ownership (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_take_ownership_finish (
    UDisksFilesystem *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_take_ownership_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *const *udisks_filesystem_get_mount_points (UDisksFilesystem *object);
gchar **udisks_filesystem_dup_mount_points (UDisksFilesystem *object);
void udisks_filesystem_set_mount_points (UDisksFilesystem *object, const gchar *const *value);

guint64 udisks_filesystem_get_size (UDisksFilesystem *object);
void udisks_filesystem_set_size (UDisksFilesystem *object, guint64 value);


/* ---- */

#define UDISKS_TYPE_FILESYSTEM_PROXY (udisks_filesystem_proxy_get_type ())
#define UDISKS_FILESYSTEM_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM_PROXY, UDisksFilesystemProxy))
#define UDISKS_FILESYSTEM_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_FILESYSTEM_PROXY, UDisksFilesystemProxyClass))
#define UDISKS_FILESYSTEM_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_FILESYSTEM_PROXY, UDisksFilesystemProxyClass))
#define UDISKS_IS_FILESYSTEM_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM_PROXY))
#define UDISKS_IS_FILESYSTEM_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_FILESYSTEM_PROXY))

typedef struct _UDisksFilesystemProxy UDisksFilesystemProxy;
typedef struct _UDisksFilesystemProxyClass UDisksFilesystemProxyClass;
typedef struct _UDisksFilesystemProxyPrivate UDisksFilesystemProxyPrivate;

struct _UDisksFilesystemProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksFilesystemProxyPrivate *priv;
};

struct _UDisksFilesystemProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_filesystem_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystemProxy, g_object_unref)
#endif

void udisks_filesystem_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksFilesystem *udisks_filesystem_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksFilesystem *udisks_filesystem_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_filesystem_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksFilesystem *udisks_filesystem_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksFilesystem *udisks_filesystem_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_FILESYSTEM_SKELETON (udisks_filesystem_skeleton_get_type ())
#define UDISKS_FILESYSTEM_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM_SKELETON, UDisksFilesystemSkeleton))
#define UDISKS_FILESYSTEM_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_FILESYSTEM_SKELETON, UDisksFilesystemSkeletonClass))
#define UDISKS_FILESYSTEM_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_FILESYSTEM_SKELETON, UDisksFilesystemSkeletonClass))
#define UDISKS_IS_FILESYSTEM_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM_SKELETON))
#define UDISKS_IS_FILESYSTEM_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_FILESYSTEM_SKELETON))

typedef struct _UDisksFilesystemSkeleton UDisksFilesystemSkeleton;
typedef struct _UDisksFilesystemSkeletonClass UDisksFilesystemSkeletonClass;
typedef struct _UDisksFilesystemSkeletonPrivate UDisksFilesystemSkeletonPrivate;

struct _UDisksFilesystemSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksFilesystemSkeletonPrivate *priv;
};

struct _UDisksFilesystemSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_filesystem_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystemSkeleton, g_object_unref)
#endif

UDisksFilesystem *udisks_filesystem_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Swapspace */

#define UDISKS_TYPE_SWAPSPACE (udisks_swapspace_get_type ())
#define UDISKS_SWAPSPACE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_SWAPSPACE, UDisksSwapspace))
#define UDISKS_IS_SWAPSPACE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_SWAPSPACE))
#define UDISKS_SWAPSPACE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_SWAPSPACE, UDisksSwapspaceIface))

struct _UDisksSwapspace;
typedef struct _UDisksSwapspace UDisksSwapspace;
typedef struct _UDisksSwapspaceIface UDisksSwapspaceIface;

struct _UDisksSwapspaceIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_set_label) (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_label,
    GVariant *arg_options);

  gboolean (*handle_start) (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_stop) (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_active) (UDisksSwapspace *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksSwapspace, g_object_unref)
#endif

GType udisks_swapspace_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_swapspace_interface_info (void);
guint udisks_swapspace_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_swapspace_complete_start (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation);

void udisks_swapspace_complete_stop (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation);

void udisks_swapspace_complete_set_label (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_swapspace_call_start (
    UDisksSwapspace *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_swapspace_call_start_finish (
    UDisksSwapspace *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_swapspace_call_start_sync (
    UDisksSwapspace *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_swapspace_call_stop (
    UDisksSwapspace *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_swapspace_call_stop_finish (
    UDisksSwapspace *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_swapspace_call_stop_sync (
    UDisksSwapspace *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_swapspace_call_set_label (
    UDisksSwapspace *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_swapspace_call_set_label_finish (
    UDisksSwapspace *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_swapspace_call_set_label_sync (
    UDisksSwapspace *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gboolean udisks_swapspace_get_active (UDisksSwapspace *object);
void udisks_swapspace_set_active (UDisksSwapspace *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_SWAPSPACE_PROXY (udisks_swapspace_proxy_get_type ())
#define UDISKS_SWAPSPACE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_SWAPSPACE_PROXY, UDisksSwapspaceProxy))
#define UDISKS_SWAPSPACE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_SWAPSPACE_PROXY, UDisksSwapspaceProxyClass))
#define UDISKS_SWAPSPACE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_SWAPSPACE_PROXY, UDisksSwapspaceProxyClass))
#define UDISKS_IS_SWAPSPACE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_SWAPSPACE_PROXY))
#define UDISKS_IS_SWAPSPACE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_SWAPSPACE_PROXY))

typedef struct _UDisksSwapspaceProxy UDisksSwapspaceProxy;
typedef struct _UDisksSwapspaceProxyClass UDisksSwapspaceProxyClass;
typedef struct _UDisksSwapspaceProxyPrivate UDisksSwapspaceProxyPrivate;

struct _UDisksSwapspaceProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksSwapspaceProxyPrivate *priv;
};

struct _UDisksSwapspaceProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_swapspace_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksSwapspaceProxy, g_object_unref)
#endif

void udisks_swapspace_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksSwapspace *udisks_swapspace_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksSwapspace *udisks_swapspace_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_swapspace_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksSwapspace *udisks_swapspace_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksSwapspace *udisks_swapspace_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_SWAPSPACE_SKELETON (udisks_swapspace_skeleton_get_type ())
#define UDISKS_SWAPSPACE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_SWAPSPACE_SKELETON, UDisksSwapspaceSkeleton))
#define UDISKS_SWAPSPACE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_SWAPSPACE_SKELETON, UDisksSwapspaceSkeletonClass))
#define UDISKS_SWAPSPACE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_SWAPSPACE_SKELETON, UDisksSwapspaceSkeletonClass))
#define UDISKS_IS_SWAPSPACE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_SWAPSPACE_SKELETON))
#define UDISKS_IS_SWAPSPACE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_SWAPSPACE_SKELETON))

typedef struct _UDisksSwapspaceSkeleton UDisksSwapspaceSkeleton;
typedef struct _UDisksSwapspaceSkeletonClass UDisksSwapspaceSkeletonClass;
typedef struct _UDisksSwapspaceSkeletonPrivate UDisksSwapspaceSkeletonPrivate;

struct _UDisksSwapspaceSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksSwapspaceSkeletonPrivate *priv;
};

struct _UDisksSwapspaceSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_swapspace_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksSwapspaceSkeleton, g_object_unref)
#endif

UDisksSwapspace *udisks_swapspace_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Encrypted */

#define UDISKS_TYPE_ENCRYPTED (udisks_encrypted_get_type ())
#define UDISKS_ENCRYPTED(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_ENCRYPTED, UDisksEncrypted))
#define UDISKS_IS_ENCRYPTED(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_ENCRYPTED))
#define UDISKS_ENCRYPTED_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_ENCRYPTED, UDisksEncryptedIface))

struct _UDisksEncrypted;
typedef struct _UDisksEncrypted UDisksEncrypted;
typedef struct _UDisksEncryptedIface UDisksEncryptedIface;

struct _UDisksEncryptedIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_change_passphrase) (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_passphrase,
    const gchar *arg_new_passphrase,
    GVariant *arg_options);

  gboolean (*handle_lock) (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_unlock) (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_passphrase,
    GVariant *arg_options);

  GVariant * (*get_child_configuration) (UDisksEncrypted *object);

  const gchar * (*get_cleartext_device) (UDisksEncrypted *object);

  const gchar * (*get_hint_encryption_type) (UDisksEncrypted *object);

  guint64  (*get_metadata_size) (UDisksEncrypted *object);

  gboolean (*handle_resize) (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksEncrypted, g_object_unref)
#endif

GType udisks_encrypted_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_encrypted_interface_info (void);
guint udisks_encrypted_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_encrypted_complete_unlock (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    const gchar *cleartext_device);

void udisks_encrypted_complete_lock (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation);

void udisks_encrypted_complete_change_passphrase (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation);

void udisks_encrypted_complete_resize (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_encrypted_call_unlock (
    UDisksEncrypted *proxy,
    const gchar *arg_passphrase,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_encrypted_call_unlock_finish (
    UDisksEncrypted *proxy,
    gchar **out_cleartext_device,
    GAsyncResult *res,
    GError **error);

gboolean udisks_encrypted_call_unlock_sync (
    UDisksEncrypted *proxy,
    const gchar *arg_passphrase,
    GVariant *arg_options,
    gchar **out_cleartext_device,
    GCancellable *cancellable,
    GError **error);

void udisks_encrypted_call_lock (
    UDisksEncrypted *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_encrypted_call_lock_finish (
    UDisksEncrypted *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_encrypted_call_lock_sync (
    UDisksEncrypted *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_encrypted_call_change_passphrase (
    UDisksEncrypted *proxy,
    const gchar *arg_passphrase,
    const gchar *arg_new_passphrase,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_encrypted_call_change_passphrase_finish (
    UDisksEncrypted *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_encrypted_call_change_passphrase_sync (
    UDisksEncrypted *proxy,
    const gchar *arg_passphrase,
    const gchar *arg_new_passphrase,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_encrypted_call_resize (
    UDisksEncrypted *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_encrypted_call_resize_finish (
    UDisksEncrypted *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_encrypted_call_resize_sync (
    UDisksEncrypted *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
GVariant *udisks_encrypted_get_child_configuration (UDisksEncrypted *object);
GVariant *udisks_encrypted_dup_child_configuration (UDisksEncrypted *object);
void udisks_encrypted_set_child_configuration (UDisksEncrypted *object, GVariant *value);

const gchar *udisks_encrypted_get_hint_encryption_type (UDisksEncrypted *object);
gchar *udisks_encrypted_dup_hint_encryption_type (UDisksEncrypted *object);
void udisks_encrypted_set_hint_encryption_type (UDisksEncrypted *object, const gchar *value);

guint64 udisks_encrypted_get_metadata_size (UDisksEncrypted *object);
void udisks_encrypted_set_metadata_size (UDisksEncrypted *object, guint64 value);

const gchar *udisks_encrypted_get_cleartext_device (UDisksEncrypted *object);
gchar *udisks_encrypted_dup_cleartext_device (UDisksEncrypted *object);
void udisks_encrypted_set_cleartext_device (UDisksEncrypted *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_ENCRYPTED_PROXY (udisks_encrypted_proxy_get_type ())
#define UDISKS_ENCRYPTED_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_ENCRYPTED_PROXY, UDisksEncryptedProxy))
#define UDISKS_ENCRYPTED_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_ENCRYPTED_PROXY, UDisksEncryptedProxyClass))
#define UDISKS_ENCRYPTED_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_ENCRYPTED_PROXY, UDisksEncryptedProxyClass))
#define UDISKS_IS_ENCRYPTED_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_ENCRYPTED_PROXY))
#define UDISKS_IS_ENCRYPTED_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_ENCRYPTED_PROXY))

typedef struct _UDisksEncryptedProxy UDisksEncryptedProxy;
typedef struct _UDisksEncryptedProxyClass UDisksEncryptedProxyClass;
typedef struct _UDisksEncryptedProxyPrivate UDisksEncryptedProxyPrivate;

struct _UDisksEncryptedProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksEncryptedProxyPrivate *priv;
};

struct _UDisksEncryptedProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_encrypted_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksEncryptedProxy, g_object_unref)
#endif

void udisks_encrypted_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksEncrypted *udisks_encrypted_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksEncrypted *udisks_encrypted_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_encrypted_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksEncrypted *udisks_encrypted_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksEncrypted *udisks_encrypted_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_ENCRYPTED_SKELETON (udisks_encrypted_skeleton_get_type ())
#define UDISKS_ENCRYPTED_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_ENCRYPTED_SKELETON, UDisksEncryptedSkeleton))
#define UDISKS_ENCRYPTED_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_ENCRYPTED_SKELETON, UDisksEncryptedSkeletonClass))
#define UDISKS_ENCRYPTED_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_ENCRYPTED_SKELETON, UDisksEncryptedSkeletonClass))
#define UDISKS_IS_ENCRYPTED_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_ENCRYPTED_SKELETON))
#define UDISKS_IS_ENCRYPTED_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_ENCRYPTED_SKELETON))

typedef struct _UDisksEncryptedSkeleton UDisksEncryptedSkeleton;
typedef struct _UDisksEncryptedSkeletonClass UDisksEncryptedSkeletonClass;
typedef struct _UDisksEncryptedSkeletonPrivate UDisksEncryptedSkeletonPrivate;

struct _UDisksEncryptedSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksEncryptedSkeletonPrivate *priv;
};

struct _UDisksEncryptedSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_encrypted_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksEncryptedSkeleton, g_object_unref)
#endif

UDisksEncrypted *udisks_encrypted_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Loop */

#define UDISKS_TYPE_LOOP (udisks_loop_get_type ())
#define UDISKS_LOOP(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOOP, UDisksLoop))
#define UDISKS_IS_LOOP(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOOP))
#define UDISKS_LOOP_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_LOOP, UDisksLoopIface))

struct _UDisksLoop;
typedef struct _UDisksLoop UDisksLoop;
typedef struct _UDisksLoopIface UDisksLoopIface;

struct _UDisksLoopIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_delete) (
    UDisksLoop *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_set_autoclear) (
    UDisksLoop *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_value,
    GVariant *arg_options);

  gboolean  (*get_autoclear) (UDisksLoop *object);

  const gchar * (*get_backing_file) (UDisksLoop *object);

  guint  (*get_setup_by_uid) (UDisksLoop *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLoop, g_object_unref)
#endif

GType udisks_loop_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_loop_interface_info (void);
guint udisks_loop_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_loop_complete_delete (
    UDisksLoop *object,
    GDBusMethodInvocation *invocation);

void udisks_loop_complete_set_autoclear (
    UDisksLoop *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_loop_call_delete (
    UDisksLoop *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_loop_call_delete_finish (
    UDisksLoop *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_loop_call_delete_sync (
    UDisksLoop *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_loop_call_set_autoclear (
    UDisksLoop *proxy,
    gboolean arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_loop_call_set_autoclear_finish (
    UDisksLoop *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_loop_call_set_autoclear_sync (
    UDisksLoop *proxy,
    gboolean arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_loop_get_backing_file (UDisksLoop *object);
gchar *udisks_loop_dup_backing_file (UDisksLoop *object);
void udisks_loop_set_backing_file (UDisksLoop *object, const gchar *value);

gboolean udisks_loop_get_autoclear (UDisksLoop *object);
void udisks_loop_set_autoclear (UDisksLoop *object, gboolean value);

guint udisks_loop_get_setup_by_uid (UDisksLoop *object);
void udisks_loop_set_setup_by_uid (UDisksLoop *object, guint value);


/* ---- */

#define UDISKS_TYPE_LOOP_PROXY (udisks_loop_proxy_get_type ())
#define UDISKS_LOOP_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOOP_PROXY, UDisksLoopProxy))
#define UDISKS_LOOP_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_LOOP_PROXY, UDisksLoopProxyClass))
#define UDISKS_LOOP_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_LOOP_PROXY, UDisksLoopProxyClass))
#define UDISKS_IS_LOOP_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOOP_PROXY))
#define UDISKS_IS_LOOP_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_LOOP_PROXY))

typedef struct _UDisksLoopProxy UDisksLoopProxy;
typedef struct _UDisksLoopProxyClass UDisksLoopProxyClass;
typedef struct _UDisksLoopProxyPrivate UDisksLoopProxyPrivate;

struct _UDisksLoopProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksLoopProxyPrivate *priv;
};

struct _UDisksLoopProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_loop_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLoopProxy, g_object_unref)
#endif

void udisks_loop_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksLoop *udisks_loop_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksLoop *udisks_loop_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_loop_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksLoop *udisks_loop_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksLoop *udisks_loop_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_LOOP_SKELETON (udisks_loop_skeleton_get_type ())
#define UDISKS_LOOP_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOOP_SKELETON, UDisksLoopSkeleton))
#define UDISKS_LOOP_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_LOOP_SKELETON, UDisksLoopSkeletonClass))
#define UDISKS_LOOP_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_LOOP_SKELETON, UDisksLoopSkeletonClass))
#define UDISKS_IS_LOOP_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOOP_SKELETON))
#define UDISKS_IS_LOOP_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_LOOP_SKELETON))

typedef struct _UDisksLoopSkeleton UDisksLoopSkeleton;
typedef struct _UDisksLoopSkeletonClass UDisksLoopSkeletonClass;
typedef struct _UDisksLoopSkeletonPrivate UDisksLoopSkeletonPrivate;

struct _UDisksLoopSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksLoopSkeletonPrivate *priv;
};

struct _UDisksLoopSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_loop_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLoopSkeleton, g_object_unref)
#endif

UDisksLoop *udisks_loop_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.MDRaid */

#define UDISKS_TYPE_MDRAID (udisks_mdraid_get_type ())
#define UDISKS_MDRAID(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MDRAID, UDisksMDRaid))
#define UDISKS_IS_MDRAID(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MDRAID))
#define UDISKS_MDRAID_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_MDRAID, UDisksMDRaidIface))

struct _UDisksMDRaid;
typedef struct _UDisksMDRaid UDisksMDRaid;
typedef struct _UDisksMDRaidIface UDisksMDRaidIface;

struct _UDisksMDRaidIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_add_device) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_device,
    GVariant *arg_options);

  gboolean (*handle_delete) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_remove_device) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_device,
    GVariant *arg_options);

  gboolean (*handle_request_sync_action) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_sync_action,
    GVariant *arg_options);

  gboolean (*handle_set_bitmap_location) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_value,
    GVariant *arg_options);

  gboolean (*handle_start) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_stop) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  GVariant * (*get_active_devices) (UDisksMDRaid *object);

  const gchar * (*get_bitmap_location) (UDisksMDRaid *object);

  GVariant * (*get_child_configuration) (UDisksMDRaid *object);

  guint64  (*get_chunk_size) (UDisksMDRaid *object);

  guint  (*get_degraded) (UDisksMDRaid *object);

  const gchar * (*get_level) (UDisksMDRaid *object);

  const gchar * (*get_name) (UDisksMDRaid *object);

  guint  (*get_num_devices) (UDisksMDRaid *object);

  gboolean  (*get_running) (UDisksMDRaid *object);

  guint64  (*get_size) (UDisksMDRaid *object);

  const gchar * (*get_sync_action) (UDisksMDRaid *object);

  gdouble  (*get_sync_completed) (UDisksMDRaid *object);

  guint64  (*get_sync_rate) (UDisksMDRaid *object);

  guint64  (*get_sync_remaining_time) (UDisksMDRaid *object);

  const gchar * (*get_uuid) (UDisksMDRaid *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksMDRaid, g_object_unref)
#endif

GType udisks_mdraid_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_mdraid_interface_info (void);
guint udisks_mdraid_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_mdraid_complete_start (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_stop (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_remove_device (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_add_device (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_set_bitmap_location (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_request_sync_action (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_delete (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_mdraid_call_start (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_start_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_start_sync (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_stop (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_stop_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_stop_sync (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_remove_device (
    UDisksMDRaid *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_remove_device_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_remove_device_sync (
    UDisksMDRaid *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_add_device (
    UDisksMDRaid *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_add_device_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_add_device_sync (
    UDisksMDRaid *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_set_bitmap_location (
    UDisksMDRaid *proxy,
    const gchar *arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_set_bitmap_location_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_set_bitmap_location_sync (
    UDisksMDRaid *proxy,
    const gchar *arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_request_sync_action (
    UDisksMDRaid *proxy,
    const gchar *arg_sync_action,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_request_sync_action_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_request_sync_action_sync (
    UDisksMDRaid *proxy,
    const gchar *arg_sync_action,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_delete (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_delete_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_delete_sync (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_mdraid_get_uuid (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_uuid (UDisksMDRaid *object);
void udisks_mdraid_set_uuid (UDisksMDRaid *object, const gchar *value);

const gchar *udisks_mdraid_get_name (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_name (UDisksMDRaid *object);
void udisks_mdraid_set_name (UDisksMDRaid *object, const gchar *value);

const gchar *udisks_mdraid_get_level (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_level (UDisksMDRaid *object);
void udisks_mdraid_set_level (UDisksMDRaid *object, const gchar *value);

guint udisks_mdraid_get_num_devices (UDisksMDRaid *object);
void udisks_mdraid_set_num_devices (UDisksMDRaid *object, guint value);

guint64 udisks_mdraid_get_size (UDisksMDRaid *object);
void udisks_mdraid_set_size (UDisksMDRaid *object, guint64 value);

const gchar *udisks_mdraid_get_sync_action (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_sync_action (UDisksMDRaid *object);
void udisks_mdraid_set_sync_action (UDisksMDRaid *object, const gchar *value);

gdouble udisks_mdraid_get_sync_completed (UDisksMDRaid *object);
void udisks_mdraid_set_sync_completed (UDisksMDRaid *object, gdouble value);

guint64 udisks_mdraid_get_sync_rate (UDisksMDRaid *object);
void udisks_mdraid_set_sync_rate (UDisksMDRaid *object, guint64 value);

guint64 udisks_mdraid_get_sync_remaining_time (UDisksMDRaid *object);
void udisks_mdraid_set_sync_remaining_time (UDisksMDRaid *object, guint64 value);

guint udisks_mdraid_get_degraded (UDisksMDRaid *object);
void udisks_mdraid_set_degraded (UDisksMDRaid *object, guint value);

const gchar *udisks_mdraid_get_bitmap_location (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_bitmap_location (UDisksMDRaid *object);
void udisks_mdraid_set_bitmap_location (UDisksMDRaid *object, const gchar *value);

guint64 udisks_mdraid_get_chunk_size (UDisksMDRaid *object);
void udisks_mdraid_set_chunk_size (UDisksMDRaid *object, guint64 value);

GVariant *udisks_mdraid_get_active_devices (UDisksMDRaid *object);
GVariant *udisks_mdraid_dup_active_devices (UDisksMDRaid *object);
void udisks_mdraid_set_active_devices (UDisksMDRaid *object, GVariant *value);

GVariant *udisks_mdraid_get_child_configuration (UDisksMDRaid *object);
GVariant *udisks_mdraid_dup_child_configuration (UDisksMDRaid *object);
void udisks_mdraid_set_child_configuration (UDisksMDRaid *object, GVariant *value);

gboolean udisks_mdraid_get_running (UDisksMDRaid *object);
void udisks_mdraid_set_running (UDisksMDRaid *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_MDRAID_PROXY (udisks_mdraid_proxy_get_type ())
#define UDISKS_MDRAID_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MDRAID_PROXY, UDisksMDRaidProxy))
#define UDISKS_MDRAID_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MDRAID_PROXY, UDisksMDRaidProxyClass))
#define UDISKS_MDRAID_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MDRAID_PROXY, UDisksMDRaidProxyClass))
#define UDISKS_IS_MDRAID_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MDRAID_PROXY))
#define UDISKS_IS_MDRAID_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MDRAID_PROXY))

typedef struct _UDisksMDRaidProxy UDisksMDRaidProxy;
typedef struct _UDisksMDRaidProxyClass UDisksMDRaidProxyClass;
typedef struct _UDisksMDRaidProxyPrivate UDisksMDRaidProxyPrivate;

struct _UDisksMDRaidProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksMDRaidProxyPrivate *priv;
};

struct _UDisksMDRaidProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_mdraid_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksMDRaidProxy, g_object_unref)
#endif

void udisks_mdraid_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksMDRaid *udisks_mdraid_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksMDRaid *udisks_mdraid_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_mdraid_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksMDRaid *udisks_mdraid_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksMDRaid *udisks_mdraid_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_MDRAID_SKELETON (udisks_mdraid_skeleton_get_type ())
#define UDISKS_MDRAID_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MDRAID_SKELETON, UDisksMDRaidSkeleton))
#define UDISKS_MDRAID_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MDRAID_SKELETON, UDisksMDRaidSkeletonClass))
#define UDISKS_MDRAID_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MDRAID_SKELETON, UDisksMDRaidSkeletonClass))
#define UDISKS_IS_MDRAID_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MDRAID_SKELETON))
#define UDISKS_IS_MDRAID_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MDRAID_SKELETON))

typedef struct _UDisksMDRaidSkeleton UDisksMDRaidSkeleton;
typedef struct _UDisksMDRaidSkeletonClass UDisksMDRaidSkeletonClass;
typedef struct _UDisksMDRaidSkeletonPrivate UDisksMDRaidSkeletonPrivate;

struct _UDisksMDRaidSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksMDRaidSkeletonPrivate *priv;
};

struct _UDisksMDRaidSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_mdraid_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksMDRaidSkeleton, g_object_unref)
#endif

UDisksMDRaid *udisks_mdraid_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Job */

#define UDISKS_TYPE_JOB (udisks_job_get_type ())
#define UDISKS_JOB(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_JOB, UDisksJob))
#define UDISKS_IS_JOB(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_JOB))
#define UDISKS_JOB_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_JOB, UDisksJobIface))

struct _UDisksJob;
typedef struct _UDisksJob UDisksJob;
typedef struct _UDisksJobIface UDisksJobIface;

struct _UDisksJobIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_cancel) (
    UDisksJob *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_cancelable) (UDisksJob *object);

  guint64  (*get_expected_end_time) (UDisksJob *object);

  const gchar *const * (*get_objects) (UDisksJob *object);

  const gchar * (*get_operation) (UDisksJob *object);

  gdouble  (*get_progress) (UDisksJob *object);

  gboolean  (*get_progress_valid) (UDisksJob *object);

  guint64  (*get_start_time) (UDisksJob *object);

  guint  (*get_started_by_uid) (UDisksJob *object);

  void (*completed) (
    UDisksJob *object,
    gboolean arg_success,
    const gchar *arg_message);

  guint64  (*get_bytes) (UDisksJob *object);

  guint64  (*get_rate) (UDisksJob *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksJob, g_object_unref)
#endif

GType udisks_job_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_job_interface_info (void);
guint udisks_job_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_job_complete_cancel (
    UDisksJob *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void udisks_job_emit_completed (
    UDisksJob *object,
    gboolean arg_success,
    const gchar *arg_message);



/* D-Bus method calls: */
void udisks_job_call_cancel (
    UDisksJob *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_job_call_cancel_finish (
    UDisksJob *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_job_call_cancel_sync (
    UDisksJob *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_job_get_operation (UDisksJob *object);
gchar *udisks_job_dup_operation (UDisksJob *object);
void udisks_job_set_operation (UDisksJob *object, const gchar *value);

gdouble udisks_job_get_progress (UDisksJob *object);
void udisks_job_set_progress (UDisksJob *object, gdouble value);

gboolean udisks_job_get_progress_valid (UDisksJob *object);
void udisks_job_set_progress_valid (UDisksJob *object, gboolean value);

guint64 udisks_job_get_bytes (UDisksJob *object);
void udisks_job_set_bytes (UDisksJob *object, guint64 value);

guint64 udisks_job_get_rate (UDisksJob *object);
void udisks_job_set_rate (UDisksJob *object, guint64 value);

guint64 udisks_job_get_start_time (UDisksJob *object);
void udisks_job_set_start_time (UDisksJob *object, guint64 value);

guint64 udisks_job_get_expected_end_time (UDisksJob *object);
void udisks_job_set_expected_end_time (UDisksJob *object, guint64 value);

const gchar *const *udisks_job_get_objects (UDisksJob *object);
gchar **udisks_job_dup_objects (UDisksJob *object);
void udisks_job_set_objects (UDisksJob *object, const gchar *const *value);

guint udisks_job_get_started_by_uid (UDisksJob *object);
void udisks_job_set_started_by_uid (UDisksJob *object, guint value);

gboolean udisks_job_get_cancelable (UDisksJob *object);
void udisks_job_set_cancelable (UDisksJob *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_JOB_PROXY (udisks_job_proxy_get_type ())
#define UDISKS_JOB_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_JOB_PROXY, UDisksJobProxy))
#define UDISKS_JOB_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_JOB_PROXY, UDisksJobProxyClass))
#define UDISKS_JOB_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_JOB_PROXY, UDisksJobProxyClass))
#define UDISKS_IS_JOB_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_JOB_PROXY))
#define UDISKS_IS_JOB_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_JOB_PROXY))

typedef struct _UDisksJobProxy UDisksJobProxy;
typedef struct _UDisksJobProxyClass UDisksJobProxyClass;
typedef struct _UDisksJobProxyPrivate UDisksJobProxyPrivate;

struct _UDisksJobProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksJobProxyPrivate *priv;
};

struct _UDisksJobProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_job_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksJobProxy, g_object_unref)
#endif

void udisks_job_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksJob *udisks_job_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksJob *udisks_job_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_job_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksJob *udisks_job_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksJob *udisks_job_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_JOB_SKELETON (udisks_job_skeleton_get_type ())
#define UDISKS_JOB_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_JOB_SKELETON, UDisksJobSkeleton))
#define UDISKS_JOB_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_JOB_SKELETON, UDisksJobSkeletonClass))
#define UDISKS_JOB_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_JOB_SKELETON, UDisksJobSkeletonClass))
#define UDISKS_IS_JOB_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_JOB_SKELETON))
#define UDISKS_IS_JOB_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_JOB_SKELETON))

typedef struct _UDisksJobSkeleton UDisksJobSkeleton;
typedef struct _UDisksJobSkeletonClass UDisksJobSkeletonClass;
typedef struct _UDisksJobSkeletonPrivate UDisksJobSkeletonPrivate;

struct _UDisksJobSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksJobSkeletonPrivate *priv;
};

struct _UDisksJobSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_job_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksJobSkeleton, g_object_unref)
#endif

UDisksJob *udisks_job_skeleton_new (void);


/* ---- */

#define UDISKS_TYPE_OBJECT (udisks_object_get_type ())
#define UDISKS_OBJECT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_OBJECT, UDisksObject))
#define UDISKS_IS_OBJECT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_OBJECT))
#define UDISKS_OBJECT_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_OBJECT, UDisksObject))

struct _UDisksObject;
typedef struct _UDisksObject UDisksObject;
typedef struct _UDisksObjectIface UDisksObjectIface;

struct _UDisksObjectIface
{
  GTypeInterface parent_iface;
};

GType udisks_object_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksObject, g_object_unref)
#endif

UDisksManager *udisks_object_get_manager (UDisksObject *object);
UDisksDrive *udisks_object_get_drive (UDisksObject *object);
UDisksDriveAta *udisks_object_get_drive_ata (UDisksObject *object);
UDisksBlock *udisks_object_get_block (UDisksObject *object);
UDisksPartitionTable *udisks_object_get_partition_table (UDisksObject *object);
UDisksPartition *udisks_object_get_partition (UDisksObject *object);
UDisksFilesystem *udisks_object_get_filesystem (UDisksObject *object);
UDisksSwapspace *udisks_object_get_swapspace (UDisksObject *object);
UDisksEncrypted *udisks_object_get_encrypted (UDisksObject *object);
UDisksLoop *udisks_object_get_loop (UDisksObject *object);
UDisksMDRaid *udisks_object_get_mdraid (UDisksObject *object);
UDisksJob *udisks_object_get_job (UDisksObject *object);
UDisksManager *udisks_object_peek_manager (UDisksObject *object);
UDisksDrive *udisks_object_peek_drive (UDisksObject *object);
UDisksDriveAta *udisks_object_peek_drive_ata (UDisksObject *object);
UDisksBlock *udisks_object_peek_block (UDisksObject *object);
UDisksPartitionTable *udisks_object_peek_partition_table (UDisksObject *object);
UDisksPartition *udisks_object_peek_partition (UDisksObject *object);
UDisksFilesystem *udisks_object_peek_filesystem (UDisksObject *object);
UDisksSwapspace *udisks_object_peek_swapspace (UDisksObject *object);
UDisksEncrypted *udisks_object_peek_encrypted (UDisksObject *object);
UDisksLoop *udisks_object_peek_loop (UDisksObject *object);
UDisksMDRaid *udisks_object_peek_mdraid (UDisksObject *object);
UDisksJob *udisks_object_peek_job (UDisksObject *object);

#define UDISKS_TYPE_OBJECT_PROXY (udisks_object_proxy_get_type ())
#define UDISKS_OBJECT_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_OBJECT_PROXY, UDisksObjectProxy))
#define UDISKS_OBJECT_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_OBJECT_PROXY, UDisksObjectProxyClass))
#define UDISKS_OBJECT_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_OBJECT_PROXY, UDisksObjectProxyClass))
#define UDISKS_IS_OBJECT_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_OBJECT_PROXY))
#define UDISKS_IS_OBJECT_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_OBJECT_PROXY))

typedef struct _UDisksObjectProxy UDisksObjectProxy;
typedef struct _UDisksObjectProxyClass UDisksObjectProxyClass;
typedef struct _UDisksObjectProxyPrivate UDisksObjectProxyPrivate;

struct _UDisksObjectProxy
{
  /*< private >*/
  GDBusObjectProxy parent_instance;
  UDisksObjectProxyPrivate *priv;
};

struct _UDisksObjectProxyClass
{
  GDBusObjectProxyClass parent_class;
};

GType udisks_object_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksObjectProxy, g_object_unref)
#endif

UDisksObjectProxy *udisks_object_proxy_new (GDBusConnection *connection, const gchar *object_path);

#define UDISKS_TYPE_OBJECT_SKELETON (udisks_object_skeleton_get_type ())
#define UDISKS_OBJECT_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_OBJECT_SKELETON, UDisksObjectSkeleton))
#define UDISKS_OBJECT_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_OBJECT_SKELETON, UDisksObjectSkeletonClass))
#define UDISKS_OBJECT_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_OBJECT_SKELETON, UDisksObjectSkeletonClass))
#define UDISKS_IS_OBJECT_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_OBJECT_SKELETON))
#define UDISKS_IS_OBJECT_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_OBJECT_SKELETON))

typedef struct _UDisksObjectSkeleton UDisksObjectSkeleton;
typedef struct _UDisksObjectSkeletonClass UDisksObjectSkeletonClass;
typedef struct _UDisksObjectSkeletonPrivate UDisksObjectSkeletonPrivate;

struct _UDisksObjectSkeleton
{
  /*< private >*/
  GDBusObjectSkeleton parent_instance;
  UDisksObjectSkeletonPrivate *priv;
};

struct _UDisksObjectSkeletonClass
{
  GDBusObjectSkeletonClass parent_class;
};

GType udisks_object_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksObjectSkeleton, g_object_unref)
#endif

UDisksObjectSkeleton *udisks_object_skeleton_new (const gchar *object_path);
void udisks_object_skeleton_set_manager (UDisksObjectSkeleton *object, UDisksManager *interface_);
void udisks_object_skeleton_set_drive (UDisksObjectSkeleton *object, UDisksDrive *interface_);
void udisks_object_skeleton_set_drive_ata (UDisksObjectSkeleton *object, UDisksDriveAta *interface_);
void udisks_object_skeleton_set_block (UDisksObjectSkeleton *object, UDisksBlock *interface_);
void udisks_object_skeleton_set_partition_table (UDisksObjectSkeleton *object, UDisksPartitionTable *interface_);
void udisks_object_skeleton_set_partition (UDisksObjectSkeleton *object, UDisksPartition *interface_);
void udisks_object_skeleton_set_filesystem (UDisksObjectSkeleton *object, UDisksFilesystem *interface_);
void udisks_object_skeleton_set_swapspace (UDisksObjectSkeleton *object, UDisksSwapspace *interface_);
void udisks_object_skeleton_set_encrypted (UDisksObjectSkeleton *object, UDisksEncrypted *interface_);
void udisks_object_skeleton_set_loop (UDisksObjectSkeleton *object, UDisksLoop *interface_);
void udisks_object_skeleton_set_mdraid (UDisksObjectSkeleton *object, UDisksMDRaid *interface_);
void udisks_object_skeleton_set_job (UDisksObjectSkeleton *object, UDisksJob *interface_);

/* ---- */

#define UDISKS_TYPE_OBJECT_MANAGER_CLIENT (udisks_object_manager_client_get_type ())
#define UDISKS_OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_OBJECT_MANAGER_CLIENT, UDisksObjectManagerClient))
#define UDISKS_OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_OBJECT_MANAGER_CLIENT, UDisksObjectManagerClientClass))
#define UDISKS_OBJECT_MANAGER_CLIENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_OBJECT_MANAGER_CLIENT, UDisksObjectManagerClientClass))
#define UDISKS_IS_OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_OBJECT_MANAGER_CLIENT))
#define UDISKS_IS_OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_OBJECT_MANAGER_CLIENT))

typedef struct _UDisksObjectManagerClient UDisksObjectManagerClient;
typedef struct _UDisksObjectManagerClientClass UDisksObjectManagerClientClass;
typedef struct _UDisksObjectManagerClientPrivate UDisksObjectManagerClientPrivate;

struct _UDisksObjectManagerClient
{
  /*< private >*/
  GDBusObjectManagerClient parent_instance;
  UDisksObjectManagerClientPrivate *priv;
};

struct _UDisksObjectManagerClientClass
{
  GDBusObjectManagerClientClass parent_class;
};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksObjectManagerClient, g_object_unref)
#endif

GType udisks_object_manager_client_get_type (void) G_GNUC_CONST;

GType udisks_object_manager_client_get_proxy_type (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data);

void udisks_object_manager_client_new (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data);
GDBusObjectManager *udisks_object_manager_client_new_finish (
    GAsyncResult        *res,
    GError             **error);
GDBusObjectManager *udisks_object_manager_client_new_sync (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error);

void udisks_object_manager_client_new_for_bus (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data);
GDBusObjectManager *udisks_object_manager_client_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
GDBusObjectManager *udisks_object_manager_client_new_for_bus_sync (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error);


G_END_DECLS

#endif /* __UDISKS_GENERATED_H__ */
