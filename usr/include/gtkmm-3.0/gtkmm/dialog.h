// Generated by gmmproc 2.60.0 -- DO NOT MODIFY!
#ifndef _GTKMM_DIALOG_H
#define _GTKMM_DIALOG_H


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

/*
 * Copyright (C) 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <vector>

#include <gtkmm/window.h>
#include <gtkmm/box.h>
#include <gtkmm/button.h>
#include <gtkmm/buttonbox.h>
#include <gtkmm/headerbar.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
using GtkDialog = struct _GtkDialog;
using GtkDialogClass = struct _GtkDialogClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Gtk
{ class Dialog_Class; } // namespace Gtk
#endif //DOXYGEN_SHOULD_SKIP_THIS

namespace Gtk
{

/** @defgroup Dialogs Dialogs
 */


/** @addtogroup gtkmmEnums gtkmm Enums and Flags */

/** 
 *  @var DialogFlags DIALOG_MODAL
 * Make the constructed dialog modal,
 * see Gtk::Window::set_modal().
 * 
 *  @var DialogFlags DIALOG_DESTROY_WITH_PARENT
 * Destroy the dialog when its
 * parent is destroyed, see Gtk::Window::set_destroy_with_parent().
 * 
 *  @var DialogFlags DIALOG_USE_HEADER_BAR
 * Create dialog with actions in header
 * bar instead of action area. @newin{3,12}
 * 
 *  @enum DialogFlags
 * 
 * Flags used to influence dialog construction.
 *
 * @ingroup gtkmmEnums
 * @par Bitwise operators:
 * <tt>%DialogFlags operator|(DialogFlags, DialogFlags)</tt><br>
 * <tt>%DialogFlags operator&(DialogFlags, DialogFlags)</tt><br>
 * <tt>%DialogFlags operator^(DialogFlags, DialogFlags)</tt><br>
 * <tt>%DialogFlags operator~(DialogFlags)</tt><br>
 * <tt>%DialogFlags& operator|=(DialogFlags&, DialogFlags)</tt><br>
 * <tt>%DialogFlags& operator&=(DialogFlags&, DialogFlags)</tt><br>
 * <tt>%DialogFlags& operator^=(DialogFlags&, DialogFlags)</tt><br>
 */
enum DialogFlags
{
  DIALOG_MODAL = 1 << 0,
  DIALOG_DESTROY_WITH_PARENT = 1 << 1,
  DIALOG_USE_HEADER_BAR = 1 << 2
};

/** @ingroup gtkmmEnums */
inline DialogFlags operator|(DialogFlags lhs, DialogFlags rhs)
  { return static_cast<DialogFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline DialogFlags operator&(DialogFlags lhs, DialogFlags rhs)
  { return static_cast<DialogFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline DialogFlags operator^(DialogFlags lhs, DialogFlags rhs)
  { return static_cast<DialogFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline DialogFlags operator~(DialogFlags flags)
  { return static_cast<DialogFlags>(~static_cast<unsigned>(flags)); }

/** @ingroup gtkmmEnums */
inline DialogFlags& operator|=(DialogFlags& lhs, DialogFlags rhs)
  { return (lhs = static_cast<DialogFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gtkmmEnums */
inline DialogFlags& operator&=(DialogFlags& lhs, DialogFlags rhs)
  { return (lhs = static_cast<DialogFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gtkmmEnums */
inline DialogFlags& operator^=(DialogFlags& lhs, DialogFlags rhs)
  { return (lhs = static_cast<DialogFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace Gtk

#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gtk::DialogFlags> : public Glib::Value_Flags<Gtk::DialogFlags>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gtk
{

/** 
 *  @var ResponseType RESPONSE_NONE
 * Returned if an action widget has no response id,
 * or if the dialog gets programmatically hidden or destroyed.
 * 
 *  @var ResponseType RESPONSE_REJECT
 * Generic response id, not used by GTK+ dialogs.
 * 
 *  @var ResponseType RESPONSE_ACCEPT
 * Generic response id, not used by GTK+ dialogs.
 * 
 *  @var ResponseType RESPONSE_DELETE_EVENT
 * Returned if the dialog is deleted.
 * 
 *  @var ResponseType RESPONSE_OK
 * Returned by OK buttons in GTK+ dialogs.
 * 
 *  @var ResponseType RESPONSE_CANCEL
 * Returned by Cancel buttons in GTK+ dialogs.
 * 
 *  @var ResponseType RESPONSE_CLOSE
 * Returned by Close buttons in GTK+ dialogs.
 * 
 *  @var ResponseType RESPONSE_YES
 * Returned by Yes buttons in GTK+ dialogs.
 * 
 *  @var ResponseType RESPONSE_NO
 * Returned by No buttons in GTK+ dialogs.
 * 
 *  @var ResponseType RESPONSE_APPLY
 * Returned by Apply buttons in GTK+ dialogs.
 * 
 *  @var ResponseType RESPONSE_HELP
 * Returned by Help buttons in GTK+ dialogs.
 * 
 *  @enum ResponseType
 * 
 * Predefined values for use as response ids in Gtk::Dialog::add_button().
 * All predefined values are negative; GTK+ leaves values of 0 or greater for
 * application-defined response ids.
 *
 * @ingroup gtkmmEnums
 */
enum ResponseType
{
  RESPONSE_NONE = -1,
  RESPONSE_REJECT = -2,
  RESPONSE_ACCEPT = -3,
  RESPONSE_DELETE_EVENT = -4,
  RESPONSE_OK = -5,
  RESPONSE_CANCEL = -6,
  RESPONSE_CLOSE = -7,
  RESPONSE_YES = -8,
  RESPONSE_NO = -9,
  RESPONSE_APPLY = -10,
  RESPONSE_HELP = -11
};

} // namespace Gtk

#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gtk::ResponseType> : public Glib::Value_Enum<Gtk::ResponseType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

namespace Gtk
{


/** Create popup windows.
 *
 * Dialog boxes are a convenient way to prompt the user for a small amount
 * of input, eg. to display a message, ask a question, or anything else that
 * does not require extensive effort on the user's part.
 *
 * gtkmm treats a dialog as a window split vertically. The top section is a
 * vertical Gtk::Box, and is where widgets such as a Gtk::Label or a Gtk::Entry should be
 * packed. The bottom area is known as the action_area. This is generally
 * used for packing buttons into the dialog which may perform functions such
 * as cancel, ok, or apply.
 *
 * The dialog can be 'modal' (that is, one which freezes the rest of the
 * application from user input) - this can be specified in the Gtk::Dialog
 * constructor.
 *
 * When adding buttons using add_button(), clicking the button will emit
 * signal_response() with a "response id" you specified. You are encouraged
 * to use the Gtk::ResponseType enum. If a dialog receives a delete event,
 * the "response" signal will be emitted with a response id of
 * Gtk::RESPONSE_DELETE_EVENT.
 *
 * If you want to block waiting for a dialog to return before returning control
 * flow to your code, you can call run(). This function enters a
 * recursive main loop and waits for the user to respond to the dialog, returning
 * the response ID corresponding to the button the user clicked.
 *
 * @ingroup Dialogs
 */

class Dialog : public Window
{
  public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  typedef Dialog CppObjectType;
  typedef Dialog_Class CppClassType;
  typedef GtkDialog BaseObjectType;
  typedef GtkDialogClass BaseClassType;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

  Dialog(Dialog&& src) noexcept;
  Dialog& operator=(Dialog&& src) noexcept;

  // noncopyable
  Dialog(const Dialog&) = delete;
  Dialog& operator=(const Dialog&) = delete;

  ~Dialog() noexcept override;

#ifndef DOXYGEN_SHOULD_SKIP_THIS

private:
  friend class Dialog_Class;
  static CppClassType dialog_class_;

protected:
  explicit Dialog(const Glib::ConstructParams& construct_params);
  explicit Dialog(GtkDialog* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:

  /** Get the GType for this class, for use with the underlying GObject type system.
   */
  static GType get_type()      G_GNUC_CONST;

#ifndef DOXYGEN_SHOULD_SKIP_THIS


  static GType get_base_type() G_GNUC_CONST;
#endif

  /// Provides access to the underlying C GObject.
  GtkDialog*       gobj()       { return reinterpret_cast<GtkDialog*>(gobject_); }

  /// Provides access to the underlying C GObject.
  const GtkDialog* gobj() const { return reinterpret_cast<GtkDialog*>(gobject_); }


public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::
  /// This is a default handler for the signal signal_response().
  virtual void on_response(int response_id);


private:

  
public:
  Dialog();
  explicit Dialog(const Glib::ustring& title, bool modal = false);
  Dialog(const Glib::ustring& title, Gtk::Window& parent, bool modal = false);
  /** @newin{3,16}
   */
  Dialog(const Glib::ustring& title, DialogFlags flags);
  /** @newin{3,16}
   */
  Dialog(const Glib::ustring& title, Gtk::Window& parent, DialogFlags flags);

  
  /** Adds an activatable widget to the action area of a Gtk::Dialog,
   * connecting a signal handler that will emit the Gtk::Dialog::signal_response()
   * signal on the dialog when the widget is activated. The widget is
   * appended to the end of the dialog’s action area. If you want to add a
   * non-activatable widget, simply pack it into the @a action_area field
   * of the Gtk::Dialog struct.
   * 
   * @param child An activatable widget.
   * @param response_id Response ID for @a child.
   */
  void add_action_widget(Widget& child, int response_id);
  
  /** Adds a button with the given text and sets things up so that
   * clicking the button will emit the Gtk::Dialog::signal_response() signal with
   * the given @a response_id. The button is appended to the end of the
   * dialog’s action area. The button widget is returned, but usually
   * you don’t need it.
   * 
   * @param button_text Text of button.
   * @param response_id Response ID for the button.
   * @return The Gtk::Button widget that was added.
   */
  Button* add_button(const Glib::ustring& button_text, int response_id);
  
#ifndef GTKMM_DISABLE_DEPRECATED

  /** Adds a button with the given text and sets things up so that
   * clicking the button will emit the Gtk::Dialog::signal_response() signal with
   * the given @a response_id. The button is appended to the end of the
   * dialog’s action area. The button widget is returned, but usually
   * you don’t need it.
   * 
   * @deprecated Use the add_button() that takes a Glib::ustring instead.
   * 
   * @param stock_id Text of button.
   * @param response_id Response ID for the button.
   * @return The Gtk::Button widget that was added.
   */
  Button* add_button(const Gtk::StockID& stock_id, int response_id);
#endif // GTKMM_DISABLE_DEPRECATED


  /** Calls `gtk_widget_set_sensitive (widget, @a setting)`
   * for each widget in the dialog’s action area with the given @a response_id.
   * A convenient way to sensitize/desensitize dialog buttons.
   * 
   * @param response_id A response ID.
   * @param setting <tt>true</tt> for sensitive.
   */
  void set_response_sensitive(int response_id, bool setting =  true);
  
  /** Sets the last widget in the dialog’s action area with the given @a response_id
   * as the default widget for the dialog. Pressing “Enter” normally activates
   * the default widget.
   * 
   * @param response_id A response ID.
   */
  void set_default_response(int response_id);
  
  /** Gets the widget button that uses the given response ID in the action area
   * of a dialog.
   * 
   * @newin{2,20}
   * 
   * @param response_id The response ID used by the @a dialog widget.
   * @return The @a widget button that uses the given
   *  @a response_id, or <tt>nullptr</tt>.
   */
  Widget* get_widget_for_response(int response_id);
  
  /** Gets the widget button that uses the given response ID in the action area
   * of a dialog.
   * 
   * @newin{2,20}
   * 
   * @param response_id The response ID used by the @a dialog widget.
   * @return The @a widget button that uses the given
   *  @a response_id, or <tt>nullptr</tt>.
   */
  const Widget* get_widget_for_response(int response_id) const;
  
  /** Gets the response id of a widget in the action area
   * of a dialog.
   * 
   * @newin{2,8}
   * 
   * @param widget A widget in the action area of @a dialog.
   * @return The response id of @a widget, or Gtk::RESPONSE_NONE
   * if @a widget doesn’t have a response id set.
   */
  int get_response_for_widget(const Gtk::Widget& widget) const;

  
#ifndef GTKMM_DISABLE_DEPRECATED

  /** Returns <tt>true</tt> if dialogs are expected to use an alternative
   * button order on the screen @a screen. See
   * Gtk::Dialog::set_alternative_button_order() for more details
   * about alternative button order.
   * 
   * If you need to use this function, you should probably connect
   * to the ::notify:gtk-alternative-button-order signal on the
   * Gtk::Settings object associated to @a screen, in order to be
   * notified if the button order setting changes.
   * 
   * @newin{2,6}
   * Deprecated: 3.10: Deprecated
   * 
   * @deprecated This should no longer be used.
   * 
   * @param screen A Gdk::Screen, or <tt>nullptr</tt> to use the default screen.
   * @return Whether the alternative button order should be used.
   */
  static bool alternative_button_order(const Glib::RefPtr<const Gdk::Screen>& screen);
#endif // GTKMM_DISABLE_DEPRECATED


#ifndef GTKMM_DISABLE_DEPRECATED

  /** Sets an alternative button order. If the gtk-alternative-button-order
   * setting is set to true, the dialog buttons are reordered according to
   * the order of the response ids in @a new_order.
   *
   * By default, GTK+ dialogs use the button order advocated by the Gnome
   * <a href="http://developer.gnome.org/hig-book/stable/">Human
   * Interface Guidelines</a> with the affirmative button at the far
   * right, and the cancel button left of it. But the builtin GTK+ dialogs
   * and MessageDialog<!-- -->s do provide an alternative button order,
   * which is more suitable on some platforms, e.g. Windows.
   *
   * Use this function after adding all the buttons to your dialog.
   *
   * @param new_order an array of response ids of the dialog's buttons.
   *
   * @newin{2,6}
   *
   * @deprecated "This should no longer be used."
   */
  void set_alternative_button_order_from_array(const std::vector<int>& new_order);
  
#endif // GTKMM_DISABLE_DEPRECATED


  /** Emits the Gtk::Dialog::signal_response() signal with the given response ID.
   * Used to indicate that the user has responded to the dialog in some way;
   * typically either you or run() will be monitoring the
   * signal_response() signal and take appropriate action.
   * 
   * @param response_id Response ID.
   */
  void response(int response_id);

  
  /** Blocks in a recursive main loop until the dialog either emits the
   * Gtk::Dialog::signal_response() signal, or is destroyed. If the dialog is
   * destroyed during the call to run(), run() returns
   * Gtk::RESPONSE_NONE. Otherwise, it returns the response ID from the
   * signal_response() signal emission.
   *
   * Before entering the recursive main loop, run() calls
   * Gtk::Widget::show() on the dialog for you. Note that you still
   * need to show any children of the dialog yourself.
   *
   * During run(), the default behavior of Gtk::Widget::signal_delete_event()
   * is disabled; if the dialog receives the signal_delete_event() signal, it will not be
   * destroyed as windows usually are, and run() will return
   * Gtk::RESPONSE_DELETE_EVENT. Also, during run() the dialog
   * will be modal. You can force run() to return at any time by
   * calling response() to emit the signal_response() signal. Destroying
   * the dialog during run() is a very bad idea, because your
   * post-run code won’t know whether the dialog was destroyed or not.
   *
   * After run() returns, you are responsible for hiding or
   * destroying the dialog if you wish to do so.
   *
   * Typical usage of this function might be:
   * @code
   * int result = dialog.run();
   * switch (result)
   * {
   * case Gtk::RESPONSE_ACCEPT:
   *   do_application_specific_something();
   *   break;
   * default:
   *   do_nothing_since_dialog_was_cancelled();
   *   break;
   * }
   * @endcode
   *
   * Note that even though the recursive main loop gives the effect of a
   * modal dialog (it prevents the user from interacting with other
   * windows in the same window group while the dialog is run), callbacks
   * such as timeouts, IO channel watches, DnD drops, etc, will
   * be triggered during a run() call.
   *
   * @return Response ID.
   */
  int run();

  // This previously returned an HButtonBox*, which broke on Maemo Fremantle.
  // Changed post-2.18.2
  
#ifndef GTKMM_DISABLE_DEPRECATED

  /** Returns the action area of @a dialog.
   * 
   * @newin{2,14}
   * 
   * Deprecated:3.12: Direct access to the action area
   * is discouraged; use add_button(), etc.
   * 
   * @deprecated Direct access to the action area is discouraged. Use add_button(), etc.
   * 
   * @return The action area.
   */
  ButtonBox* get_action_area();
#endif // GTKMM_DISABLE_DEPRECATED


#ifndef GTKMM_DISABLE_DEPRECATED

  /** Returns the action area of @a dialog.
   * 
   * @newin{2,14}
   * 
   * Deprecated:3.12: Direct access to the action area
   * is discouraged; use add_button(), etc.
   * 
   * @deprecated Direct access to the action area is discouraged. Use add_button(), etc.
   * 
   * @return The action area.
   */
  const ButtonBox* get_action_area() const;
#endif // GTKMM_DISABLE_DEPRECATED


#ifndef GTKMM_DISABLE_DEPRECATED

  /** Returns the content area of @a dialog.
   * 
   * @newin{2,14}
   * 
   * @deprecated Use get_content_area() instead.
   * 
   * @return The content area Gtk::Box.
   */
  Box* get_vbox();
#endif // GTKMM_DISABLE_DEPRECATED


#ifndef GTKMM_DISABLE_DEPRECATED

  /** Returns the content area of @a dialog.
   * 
   * @newin{2,14}
   * 
   * @deprecated Use get_content_area() instead.
   * 
   * @return The content area Gtk::Box.
   */
  const Box* get_vbox() const;
#endif // GTKMM_DISABLE_DEPRECATED


  /** Returns the content area of @a dialog.
   * 
   * @newin{2,14}
   * 
   * @return The content area Gtk::Box.
   */
  Box* get_content_area();
  
  /** Returns the content area of @a dialog.
   * 
   * @newin{2,14}
   * 
   * @return The content area Gtk::Box.
   */
  const Box* get_content_area() const;

  
  /** Returns the header bar of @a dialog. Note that the
   * headerbar is only used by the dialog if the
   * Gtk::Dialog::property_use_header_bar() property is <tt>true</tt>.
   * 
   * @newin{3,12}
   * 
   * @return The header bar.
   */
  HeaderBar* get_header_bar(); // transfer none
  
  /** Returns the header bar of @a dialog. Note that the
   * headerbar is only used by the dialog if the
   * Gtk::Dialog::property_use_header_bar() property is <tt>true</tt>.
   * 
   * @newin{3,12}
   * 
   * @return The header bar.
   */
  const HeaderBar* get_header_bar() const; // transfer none

  
  /**
   * @par Slot Prototype:
   * <tt>void on_my_%response(int response_id)</tt>
   *
   * Flags: Run Last
   *
   * Emitted when an action widget is clicked, the dialog receives a
   * delete event, or the application programmer calls Gtk::Dialog::response().
   * On a delete event, the response ID is Gtk::RESPONSE_DELETE_EVENT.
   * Otherwise, it depends on which action widget was clicked.
   * 
   * @param response_id The response ID.
   */

  Glib::SignalProxy< void,int > signal_response();


  //_WRAP_PROPERTY("has-separator", bool) //deprecated.
  /** <tt>true</tt> if the dialog uses a Gtk::HeaderBar for action buttons
   * instead of the action-area.
   * 
   * For technical reasons, this property is declared as an integer
   * property, but you should only set it to <tt>true</tt> or <tt>false</tt>.
   * 
   * @newin{3,12}
   *
   * Default value: -1
   *
   * @return A PropertyProxy_ReadOnly that allows you to get the value of the property,
   * or receive notification when the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly< bool > property_use_header_bar() const;


};

} //namespace Gtk


namespace Glib
{
  /** A Glib::wrap() method for this object.
   *
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gtk::Dialog
   */
  Gtk::Dialog* wrap(GtkDialog* object, bool take_copy = false);
} //namespace Glib


#endif /* _GTKMM_DIALOG_H */

