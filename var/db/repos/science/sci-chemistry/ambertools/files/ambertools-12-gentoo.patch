 AmberTools/src/Makefile                            |  42 +-
 AmberTools/src/configure2                          |  63 +-
 AmberTools/src/cpptraj/src/Makefile_at             |  14 +-
 AmberTools/src/mdgx/Makefile                       |   9 +-
 AmberTools/src/mdgx/Trajectory.c                   |   2 +-
 .../src/mmpbsa_py/MMPBSA_mods/amber_outputs.py     |   4 +-
 AmberTools/src/nab/database.c                      |   2 +-
 AmberTools/src/nab/nab.c                           |   4 +-
 AmberTools/src/pbsa/Makefile                       |  44 +-
 AmberTools/src/ptraj/Makefile                      |   9 +-
 AmberTools/src/ptraj/trajectory.c                  |   2 +-
 AmberTools/src/sff/Makefile                        |   4 +-
 AmberTools/src/sff/dsarpack.f                      | 654 +++++++++++++++++++++
 AmberTools/src/sqm/Makefile                        |   7 +-
 AmberTools/test/Makefile                           |   4 +-
 .../01_Generalized_Born/energies.csv.save          |   8 +-
 AmberTools/test/nab/Makefile                       |   2 +
 AmberTools/test/nab/Run.rism_sp                    |   2 +-
 AmberTools/test/nab/Run.rism_sp2                   |   2 +-
 AmberTools/test/test_at_serial.sh                  |   6 +
 Makefile                                           |   2 +-
 21 files changed, 725 insertions(+), 161 deletions(-)

diff --git a/AmberTools/src/Makefile b/AmberTools/src/Makefile
index e5c0ded..ce8f883 100644
--- a/AmberTools/src/Makefile
+++ b/AmberTools/src/Makefile
@@ -13,12 +13,6 @@ install: $(INSTALLTYPE)
 serial: configured_serial THIRDPARTY $(MTKPP)
 	@echo "Starting installation of ${AMBERTOOLS} serial at `date`".
 #	utility routines and libraries:
-	(cd ucpp-1.3 && $(MAKE) $(UCPP) )
-	(cd byacc && $(MAKE) install )
-	(cd arpack && $(MAKE) install );
-	(cd lapack && $(MAKE) $(LAPACK) )
-	(cd blas && $(MAKE) $(BLAS) )
-	(cd c9x-complex && $(MAKE) $(C9XCOMPLEX) )
 	(cd etc && $(MAKE) install )
 	(cd chamber && $(MAKE) install )
 	(cd pbsa && $(MAKE) install )
@@ -34,13 +28,11 @@ serial: configured_serial THIRDPARTY $(MTKPP)
 	(cd cpptraj && $(MAKE) install)
 
 #   miscellaneous:
-	(cd reduce && $(MAKE) install )
 
 #   leap
 	(cd leap && $(MAKE) install )
 
 #   nab:
-	(cd cifparse && $(MAKE) install )
 	(cd sff && $(MAKE) install )
 	(cd pbsa && $(MAKE) libinstall )
 	(cd rism && $(MAKE) $(RISM) )
@@ -77,17 +69,10 @@ serial: configured_serial THIRDPARTY $(MTKPP)
 	@echo "Installation of ${AMBERTOOLS} serial is complete at `date`."
 	@echo ""
 
-nabonly: $(NETCDF) $(XBLAS)  
+nabonly: $(XBLAS)
 #	utility routines and libraries:
-	(cd ucpp-1.3 && $(MAKE) $(UCPP) )
-	(cd byacc && $(MAKE) install )
-	(cd arpack && $(MAKE) install );
-	(cd lapack && $(MAKE) $(LAPACK) )
-	(cd blas && $(MAKE) $(BLAS) )
-	(cd c9x-complex && $(MAKE) $(C9XCOMPLEX) )
 	(cd pbsa && $(MAKE) libinstall )
 	(cd rism && $(MAKE) $(RISM) )
-	(cd cifparse && $(MAKE) install )
 	(cd sff && $(MAKE) install )
 	(cd nab && $(MAKE) install )
 	(cd nss && $(MAKE) install )
@@ -119,8 +104,6 @@ parallel: configured_parallel THIRDPARTY
 	(cd sff && $(MAKE) libsff_mpi )
 #	(cd pbsa && $(MAKE) clean && $(MAKE) install.parallel )
 	(cd pbsa && $(MAKE) libinstall )
-	(cd byacc && $(MAKE) install )
-	(cd ucpp-1.3 && $(MAKE) $(UCPP) )
 #	(cd mdgx && $(MAKE) parallel )
 	(if [ "$(RISM)" = "yes" ]; then \
 		cd rism && $(MAKE) install_mpi ; \
@@ -162,18 +145,11 @@ configured_parallel: configured
 	)
 
 clean::  netcdf_clean
-	-(cd ucpp-1.3 && $(MAKE) clean )
-	-(cd byacc && $(MAKE) clean )
-	-(cd cifparse && $(MAKE) clean )
 	-(cd nab && $(MAKE) clean )
 	-(cd sff && $(MAKE) clean )
 	-(cd nss && $(MAKE) clean )
 	-(cd leap && $(MAKE) clean )
-	-(cd arpack && $(MAKE) clean )
-	-(cd blas && $(MAKE) clean )
 	-(cd xblas && $(MAKE) clean )
-	-(cd lapack && $(MAKE) clean )
-	-(cd c9x-complex && $(MAKE) clean )
 	-(cd etc && $(MAKE) clean )
 	-(cd chamber && $(MAKE) clean )
 	-(cd pbsa && $(MAKE) clean )
@@ -182,15 +158,12 @@ clean::  netcdf_clean
 	-(cd lib && $(MAKE) clean )
 	-(cd ptraj && $(MAKE) clean )
 	-(cd cpptraj && $(MAKE) clean)
-	-(cd reduce && $(MAKE) clean )
 	-(cd mtkpp && $(MAKE) clean )
 	-(cd mdgx && $(MAKE) clean )
 	-(cd xtalutil/CPrograms && $(MAKE) clean )
 	-(cd xray && $(MAKE) clean )
 	-(cd paramfit && $(MAKE) clean )
 	-(cd rism && $(MAKE) clean )
-	-(cd fftw-3.3 && $(MAKE) clean )
-	-($(RM) -f fftw-3.3/mpi/fftw3-mpi.f03 )
 	-(cd mmpbsa_py && $(MAKE) clean )
 	-(cd parmed && $(MAKE) clean )
 
@@ -201,18 +174,11 @@ netcdf_clean:
 	-(cd netcdf/bin && rm -f *)
 
 uninstall:
-	-(cd ucpp-1.3 && $(MAKE) uninstall )
-	-(cd byacc && $(MAKE) uninstall )
-	-(cd cifparse && $(MAKE) uninstall )
 	-(cd nab && $(MAKE) uninstall )
 	-(cd sff && $(MAKE) uninstall )
 	-(cd nss && $(MAKE) uninstall )
 	-(cd leap && $(MAKE) uninstall )
-	-(cd arpack && $(MAKE) uninstall )
-	-(cd blas && $(MAKE) uninstall )
 	-($(RM) -f $(LIBDIR)/libxblas.a )
-	-(cd lapack && $(MAKE) uninstall )
-	-(cd c9x-complex && $(MAKE) uninstall )
 	-(cd etc && $(MAKE) uninstall )
 	-(cd chamber && $(MAKE) uninstall )
 	-(cd pbsa && $(MAKE) uninstall )
@@ -220,7 +186,6 @@ uninstall:
 	-(cd sqm && $(MAKE) uninstall )
 	-(cd lib && $(MAKE) uninstall )
 	-(cd ptraj && $(MAKE) uninstall )
-	-(cd reduce && $(MAKE) uninstall )
 	-(cd mdgx && $(MAKE) uninstall )
 	-(cd xtalutil/CPrograms && $(MAKE) uninstall )
 	-(cd xray && $(MAKE) uninstall )
@@ -228,15 +193,12 @@ uninstall:
 	-(cd paramfit && $(MAKE) uninstall )
 	-(cd rism && $(MAKE) uninstall )
 	-(cd netcdf/src && $(MAKE) uninstall)
-	-(cd fftw-3.3 && $(MAKE) uninstall)
 	-(cd cpptraj && $(MAKE) uninstall)
 	-(cd mmpbsa_py && $(MAKE) uninstall )
 	-(cd parmed && $(MAKE) uninstall )
 	-(cd amberlite && $(MAKE) uninstall )
 	-/bin/rm -f ../test/numprocs
 	-/bin/rm -fr $(BINDIR)/ncmpidump $(BINDIR)/ncmpigen $(BINDIR)/ncvalid $(LIBDIR)/libnetcdf.a $(INCDIR)/mtkpp
-	-(cd $(LIBDIR) && /bin/rm -f libxblas-amb.a libfftw3_mpi.a libfftw3_mpi.la)
-	-(cd $(INCDIR) && /bin/rm -f fftw3-mpi.f03 fftw3-mpi.h)
 
 $(INCDIR)/netcdf.mod:
 	cd netcdf/src && $(MAKE) && $(MAKE) -j 1 install
@@ -247,7 +209,7 @@ $(LIBDIR)/libxblas-amb.a:
 $(LIBDIR)/libfftw3.a $(LIBDIR)/libfftw3_mpi.a: 
 	cd fftw-3.3 && $(MAKE) && $(MAKE) -j 1 install;
 
-THIRDPARTY: $(NETCDF) $(XBLAS) $(FFTW3)
+THIRDPARTY: $(XBLAS)
 
 cuda:
 	@echo "$(AMBERTOOLS) has no CUDA-enabled components"
diff --git a/AmberTools/src/configure2 b/AmberTools/src/configure2
index 25d3f0a..1ad86e6 100755
--- a/AmberTools/src/configure2
+++ b/AmberTools/src/configure2
@@ -387,11 +387,11 @@ omp_flag=
 mpi_flag=
 lex=flex
 flibs_mkl=
-lapack=install
-blas=install
+lapack=skip
+blas=skip
 f2c=skip
-ucpp=install
-cpp="ucpp -l"
+ucpp=skip
+cpp="\$(EPREFIX)/usr/bin/ucpp -l"
 
 #-----------------------------------
 # skip building of xleap?
@@ -618,13 +618,14 @@ gnu)
     flibs_arch="-lgfortran -w"
     flibsf_arch=
     cc=gcc
-    cflags=
+    cflags="GENTOO_CFLAGS"
     ambercflags=""
     cplusplus=g++
-    cxxflags=
+    cxxflags="GENTOO_CXXFLAGS"
     ambercxxflags=""
     fc=gfortran
-    fflags=
+    fflags="GENTOO_FFLAGS"
+    ldflags="GENTOO_LDFLAGS"
     staticflag='-static'
     
     # If -noopt has been requested, force lack of optimisation;
@@ -645,11 +646,11 @@ gnu)
       foptflags=""
     else
       cnooptflags=
-      coptflags="-O3"
+      coptflags="GENTOO_CFLAGS"
       cxxnooptflags=
-      cxxoptflags="-O3"
+      cxxoptflags="GENTOO_CXXFLAGS"
       fnooptflags="-O0"
-      foptflags="-O3"
+      foptflags="GENTOO_FFLAGS"
     fi
     
     # Debugging options
@@ -2026,26 +2027,26 @@ EOF
       if [ "$sse" = "yes" ]; then
           enable_sse="--enable-sse2=yes" # --enable-avx=yes"
       fi
-      cd fftw-3.3 && \
-	  ./configure --prefix=$AMBERHOME --libdir=$AMBERHOME/lib \
-          --enable-static=yes \
-          $enable_mpi $enable_debug $enable_sse\
-	  CC="$cc" CFLAGS="$cflags $coptflags" \
-          F77="$fc" FFLAGS="$fflags $foptflags" \
-          FLIBS="$flibs_arch" \
-	  > ../fftw3_config.log 2>&1
-      ncerror=$?
-      if [ $ncerror -gt 0 ]; then
-          echo "    Error: FFTW configure returned $ncerror"
-          echo "    FFTW configure failed! Check the fftw3_config.log file"
-          echo "    in the $AMBERHOME/AmberTools/src diretory."
-          exit 1
-      else
-          echo "    fftw-3.3 configure succeeded."
-      fi
-      cd ..
+#      cd fftw-3.3 && \
+#	  ./configure --prefix=$AMBERHOME --libdir=$AMBERHOME/lib \
+#          --enable-static=yes \
+#          $enable_mpi $enable_debug $enable_sse\
+#	  CC="$cc" CFLAGS="$cflags $coptflags" \
+#          F77="$fc" FFLAGS="$fflags $foptflags" \
+#          FLIBS="$flibs_arch" \
+#	  > ../fftw3_config.log 2>&1
+#      ncerror=$?
+#      if [ $ncerror -gt 0 ]; then
+#          echo "    Error: FFTW configure returned $ncerror"
+#          echo "    FFTW configure failed! Check the fftw3_config.log file"
+#          echo "    in the $AMBERHOME/AmberTools/src diretory."
+#          exit 1
+#      else
+#          echo "    fftw-3.3 configure succeeded."
+#      fi
+#      cd ..
       fftw3="FFTW3"
-      flibs_fftw3="-lfftw3"
+      flibs_fftw3="GENTOO_FFTW3_LIBS"
       fftw3="\$(LIBDIR)/libfftw3.a"
       if [ "$mpi" = 'yes' ]; then
           flibs_fftw3="-lfftw3_mpi $flibs_fftw3"
@@ -2282,7 +2283,7 @@ LDFLAGS=$ldflags \$(CUSTOMBUILDFLAGS)
 AMBERLDFLAGS=\$(AMBERBUILDFLAGS)
 
 LEX=   $lex
-YACC=  \$(BINDIR)/yacc
+YACC=  byacc
 AR=    ar rv
 M4=    $m4
 RANLIB=$ranlib
@@ -2319,7 +2320,7 @@ CP=$localcp
 #  Information about Fortran compilation:
 
 FC=$fc
-FFLAGS= $fflags \$(LOCALFLAGS) \$(CUSTOMBUILDFLAGS) -I\$(INCDIR) \$(NETCDFINC) $mklinc
+FFLAGS= $fflags \$(LOCALFLAGS) \$(CUSTOMBUILDFLAGS) -IGENTOO_INCLUDE \$(NETCDFINC) $mklinc
 FNOOPTFLAGS= $fnooptflags
 FOPTFLAGS= $foptflags
 AMBERFFLAGS=\$(AMBERBUILDFLAGS)
diff --git a/AmberTools/src/cpptraj/src/Makefile_at b/AmberTools/src/cpptraj/src/Makefile_at
index 822b451..0684b0c 100644
--- a/AmberTools/src/cpptraj/src/Makefile_at
+++ b/AmberTools/src/cpptraj/src/Makefile_at
@@ -29,22 +29,10 @@ dependclean:
 	-/bin/rm FindDepend.o
 	-/bin/rm findDepend
 
-cpptraj$(SFX): $(NETCDF) $(OBJECTS) $(PTRAJ_OBJECTS) $(EXTERNAL_LIBS) 
+cpptraj$(SFX): $(OBJECTS) $(PTRAJ_OBJECTS)
 	$(CXX) $(LDFLAGS) -o cpptraj$(SFX) $(OBJECTS) $(PTRAJ_OBJECTS) \
                -L$(LIBDIR) $(NETCDFLIB) $(ZLIB) $(BZLIB) $(FLIBS_PTRAJ)
 
-$(INCDIR)/netcdf.mod: ../../netcdf_config.log
-	cd ../../netcdf/src && $(MAKE) install
-
-$(LIBDIR)/libarpack.a:
-	cd ../../arpack && $(MAKE) install
-
-$(LIBDIR)/liblapack.a:
-	cd ../../lapack && $(MAKE) $(LAPACK)
-
-$(LIBDIR)/libblas.a:
-	cd ../../blas && $(MAKE) $(BLAS)
-
 thermo.o:  ../../ptraj/thermo.F90
 	$(FC) $(FPPFLAGS) -c $(FREEFORMAT_FLAG) $(FOPTFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@ ../../ptraj/thermo.F90
 
diff --git a/AmberTools/src/mdgx/Makefile b/AmberTools/src/mdgx/Makefile
index 7bad950..b7a560b 100644
--- a/AmberTools/src/mdgx/Makefile
+++ b/AmberTools/src/mdgx/Makefile
@@ -132,19 +132,16 @@ MDGX_HEADERS = \
 	       ptrajmask.h \
 	       ../sff/AmberNetcdf.h 
 
-mdgx$(SFX) : $(MDGX_OBJS) $(LIBDIR)/libfftw3.a
+mdgx$(SFX) : $(MDGX_OBJS)
 	$(CC) $(COPTFLAGS) $(CFLAGS) $(AMBERCFLAGS) $(LDFLAGS) \
 	-o $@ $(MDGX_OBJS) $(FFTWLIB) -L$(LIBDIR) $(NETCDFLIB) $(LM)
 
-mdgx.MPI$(SFX) : $(MDGX_OBJS) $(LIBDIR)/libfftw3.a
+mdgx.MPI$(SFX) : $(MDGX_OBJS)
 	$(CC) $(COPTFLAGS) $(CFLAGS) $(AMBERCFLAGS) $(LDFLAGS) \
 	-o $@ $(MDGX_OBJS) $(FFTWLIB) -L$(LIBDIR) $(NETCDFLIB) $(LM)
 
-$(LIBDIR)/fftw3.a: ../fftw-3.3/config.log
-	cd ../fftw-3.3 && $(MAKE) && $(MAKE) -j 1 install;
-
 .c.o:
-	$(CC) -c $(COPTFLAGS) $(CFLAGS) $(AMBERCFLAGS) -I$(INCDIR) -I../fftw-3.3/api -o $@ $<
+	$(CC) -c $(COPTFLAGS) $(CFLAGS) $(AMBERCFLAGS) -I$(INCDIR) -o $@ $<
 
 clean:
 	/bin/rm -f $(MDGX_OBJS) mdgx$(SFX)
diff --git a/AmberTools/src/mdgx/Trajectory.c b/AmberTools/src/mdgx/Trajectory.c
index 524dad8..5df64c6 100644
--- a/AmberTools/src/mdgx/Trajectory.c
+++ b/AmberTools/src/mdgx/Trajectory.c
@@ -214,7 +214,7 @@ void ExtendCoordinates(coord *tc, prmtop *tp)
 coord ReadRst(prmtop *tp, char* source)
 {
   int i, rsttype;
-  char line[128];
+  char line[MAXLINE];
   FILE *inp;
   coord tc;
 
diff --git a/AmberTools/src/mmpbsa_py/MMPBSA_mods/amber_outputs.py b/AmberTools/src/mmpbsa_py/MMPBSA_mods/amber_outputs.py
index b01b891..24ea20f 100644
--- a/AmberTools/src/mmpbsa_py/MMPBSA_mods/amber_outputs.py
+++ b/AmberTools/src/mmpbsa_py/MMPBSA_mods/amber_outputs.py
@@ -210,7 +210,7 @@ class AmberOutput(object):
 
       # write out each frame
       for i in range(len(self.data[print_keys[0]])):
-         csvwriter.writerow([i] + [self.data[key][i] for key in print_keys])
+         csvwriter.writerow([i] + ["%.4f" % self.data[key][i] for key in print_keys])
 
    #==================================================
 
@@ -1003,7 +1003,7 @@ class BindingStatistics(object):
 
          # write out each frame
          for i in range(len(self.data[print_keys[0]])):
-            csvwriter.writerow([i]+[self.data[key][i] for key in print_keys])
+            csvwriter.writerow([i]+["%.4f" % self.data[key][i] for key in print_keys])
          csvwriter.writerow([])
 
    #==================================================
diff --git a/AmberTools/src/nab/database.c b/AmberTools/src/nab/database.c
index 0b98d35..9aad62a 100644
--- a/AmberTools/src/nab/database.c
+++ b/AmberTools/src/nab/database.c
@@ -1135,7 +1135,7 @@ int*		iPLines;
 char*           PBuffer;
 int             iBufferInc;
 {
-String          sLine;
+String          sLine[MAXDATALINELEN];
 
 
 
diff --git a/AmberTools/src/nab/nab.c b/AmberTools/src/nab/nab.c
index 84e03ef..d49b711 100644
--- a/AmberTools/src/nab/nab.c
+++ b/AmberTools/src/nab/nab.c
@@ -161,8 +161,8 @@ char	*cppstring;
                fprintf( stderr, "AMBERHOME is not set!\n" );
                exit(1);
             }
-			sprintf( cmd, "%s/bin/%s %s -I%s/include %s ",
-				amberhome, CPP, cppstring, amberhome,
+			sprintf( cmd, "%s %s -I%s/include %s ",
+				CPP, cppstring, amberhome,
 				argv[ ac ] ? argv[ ac ] : "" );
 			if( cgdopt ) fprintf( stderr, "cpp cmd: %s\n", cmd );
 			nfields = split( cmd, fields, " " );
diff --git a/AmberTools/src/pbsa/Makefile b/AmberTools/src/pbsa/Makefile
index 0a3f12f..2105b00 100644
--- a/AmberTools/src/pbsa/Makefile
+++ b/AmberTools/src/pbsa/Makefile
@@ -144,23 +144,23 @@ configured_parallel: configured
 	)
 
 #---------------------------------------------------------------------------
-pbsa$(SFX): FFTW3 $(OBJ) syslib netlib c9x-complex configured_serial 
+pbsa$(SFX): $(OBJ) syslib configured_serial 
 	$(FC) $(PBSAFLAG) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o pbsa$(SFX) $(OBJ) \
 	        ../lib/nxtsec.o ../lib/random.o $(FLIBS_FFTW3) \
 	        -L$(LIBDIR) $(FLIBSF) $(LDFLAGS) $(AMBERLDFLAGS)
 
-pbsa.MPI$(SFX): FFTW3.MPI $(OBJ) syslib netlib c9x-complex configured_parallel 
+pbsa.MPI$(SFX): $(OBJ) syslib configured_parallel 
 	$(FC) $(PBSAFLAG) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o pbsa.MPI$(SFX) $(OBJ) \
 	        ../lib/nxtsec.o ../lib/random.o $(FLIBS_FFTW3) \
 	        -L$(LIBDIR) $(FLIBSF) $(LDFLAGS) $(AMBERLDFLAGS)
 
-simplepbsa$(SFX): simplepbsa.o gopt.o libpbsa.a sfflib syslib netlib c9x-complex
+simplepbsa$(SFX): simplepbsa.o gopt.o libpbsa.a sfflib syslib
 	$(FC) $(PBSAFLAG) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o simplepbsa$(SFX) simplepbsa.o gopt.o \
 		libpbsa.a $(LIBDIR)/libsff.a ../lib/nxtsec.o -L$(LIBDIR) $(FLIBSF) \
 		$(LDFLAGS) $(AMBERLDFLAGS)
 	/bin/mv simplepbsa$(SFX) $(BINDIR)
 
-libpbsa.a: FFTW3 $(LIBPBSAOBJS) syslib
+libpbsa.a: $(LIBPBSAOBJS) syslib
 	-rm -f libpbsa.a
 	$(AR) libpbsa.a $(LIBPBSAOBJS) ../lib/random.o
 	$(RANLIB) libpbsa.a
@@ -188,48 +188,12 @@ libFpbsa.parallel: $(SANDERPBSAOBJS)
 	$(RANLIB) libFpbsa.a
 	/bin/mv libFpbsa.a $(LIBDIR)
 
-FFTW3:
-	@if [ "$(PBSAFLAG)" = "-DFFTW" ]; then \
-	if [ "$(FLIBS_FFTW3)" = '-lfftw3xf_$(COMPILER)' ]; then\
-		cd $(MKL)/interfaces/fftw3xf && $(MAKE) lib$(MKL_PROCESSOR) \
-		compiler=$(COMPILER) PRECISION=MKL_DOUBLE \
-		INSTALL_DIR=$(LIBDIR); \
-	else \
-	    if [ ! -f $(INCDIR)/fftw3.f03 ]; then\
-		cd ../fftw-3.3 && $(MAKE) && $(MAKE) -j 1 install; \
-	    fi \
-	fi \
-	fi
-
-FFTW3.MPI:
-	@if [ "$(PBSAFLAG)" = "-DFFTW" ]; then \
-	if [ "$(FLIBS_FFTW3)" = '-lfftw3xf_$(COMPILER)' ]; then\
-		cd $(MKL)/interfaces/fftw3xf && $(MAKE) lib$(MKL_PROCESSOR) \
-		compiler=$(COMPILER) PRECISION=MKL_DOUBLE \
-		INSTALL_DIR=$(LIBDIR); \
-	else \
-	    if [ ! -f $(INCDIR)/fftw3-mpi.f03 ]; then\
-		cd ../fftw-3.3 && $(MAKE) && $(MAKE) -j 1 install; \
-	    fi \
-	fi \
-	fi
-
 syslib:
 	cd ../lib && $(MAKE) nxtsec.o random.o
 
 sfflib:
 	cd ../sff && $(MAKE) install
 
-netlib: 
-	cd ../lapack && $(MAKE) $(LAPACK)
-	cd ../blas && $(MAKE) $(BLAS)
-	cd ../arpack && $(MAKE) install
-
-c9x-complex:
-	@if test $(C9XCOMPLEX) != "skip"; then \
-	   cd ../c9x-complex && $(MAKE) libmc.a; \
-	 fi
-
 pb_init.o: pb_init.F90
 	$(FC) $(PBSAFLAG) $(FPPFLAGS) -c -O0 $(FFLAGS) $(AMBERFFLAGS) -o $@ $<
 
diff --git a/AmberTools/src/ptraj/Makefile b/AmberTools/src/ptraj/Makefile
index 3e643b9..b3089f1 100644
--- a/AmberTools/src/ptraj/Makefile
+++ b/AmberTools/src/ptraj/Makefile
@@ -61,21 +61,16 @@ rdparm$(SFX): libs $(OBJECTS)
 	$(CC) $(CFLAGS) $(AMBERCFLAGS) $(LDFLAGS) $(AMBERLDFLAGS) \
 		-o rdparm$(SFX) $(OBJECTS) $(LIBS) $(NETCDFLIB) $(LM)
 
-ptraj$(SFX): libs netlib $(OBJECTS)
+ptraj$(SFX): libs $(OBJECTS)
 	$(CC) $(CFLAGS) $(AMBERCFLAGS) $(LDFLAGS) $(AMBERLDFLAGS) \
 		-o ptraj$(SFX) $(OBJECTS) $(LIBS) $(NETCDFLIB) $(LM)
 
-ptraj.MPI$(SFX): libs netlib $(OBJECTS)
+ptraj.MPI$(SFX): libs $(OBJECTS)
 	$(CC) $(CFLAGS) $(AMBERCFLAGS) $(LDFLAGS) $(AMBERLDFLAGS) \
 		-o ptraj.MPI$(SFX) $(OBJECTS) $(LIBS) $(PNETCDFLIB) $(LM)
 
 libs: 
 	cd pdb && $(MAKE) 
-	cd ../arpack && $(MAKE)
-
-netlib:
-	cd ../lapack && $(MAKE) $(LAPACK)
-	cd ../blas && $(MAKE) $(BLAS)
 
 clean:
 	cd pdb && $(MAKE) clean
diff --git a/AmberTools/src/ptraj/trajectory.c b/AmberTools/src/ptraj/trajectory.c
index 110ffce..49bdf1a 100644
--- a/AmberTools/src/ptraj/trajectory.c
+++ b/AmberTools/src/ptraj/trajectory.c
@@ -1315,7 +1315,7 @@ readAmberTrajectory_nobuffer(FILE *fpin, int natoms,
 {
   fpos_t fileMarker;         /* marker for current file postition */
   char *junk;
-  char buffer[120];
+  char buffer[BUFFER_SIZE];
   char coords[26];    /* room for 24 characters (3f8.3) + \n + (char) 0  */
   char c;     
   int j,ret;
diff --git a/AmberTools/src/sff/Makefile b/AmberTools/src/sff/Makefile
index 83f362c..13efc78 100644
--- a/AmberTools/src/sff/Makefile
+++ b/AmberTools/src/sff/Makefile
@@ -3,7 +3,7 @@ include ../config.h
 .c.o:
 	$(CC) -c -Dflex $(COPTFLAGS) $(CFLAGS) $(AMBERCFLAGS) $(RISMSFF) $(NETCDFINC) -o $@ $<
 
-OBJS = binpos.o conjgrad.o lmodC.o memutil.o nblist.o newton.o nmode.o \
+OBJS = binpos.o conjgrad.o dsarpack.o lmodC.o memutil.o nblist.o newton.o nmode.o \
 	prm.o rand2.o sasad.o sff.o time.o xminC.o AmberNetcdf.o $(SFF_RISM_INTERFACE)
 
 
@@ -63,7 +63,7 @@ xminC.o:  sff.h
 AmberNetcdf.o:  AmberNetcdf.h
 
 hcp_getpdb: hcp_getpdb.c
-	$(CC) -o $(BINDIR)/hcp_getpdb hcp_getpdb.c
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $(BINDIR)/hcp_getpdb hcp_getpdb.c
 
 .PHONY: ../rism/amber_rism_interface.NAB.o
 ../rism/amber_rism_interface.NAB.o:
diff --git a/AmberTools/src/sff/dsarpack.f b/AmberTools/src/sff/dsarpack.f
new file mode 100644
index 0000000..5544df9
--- /dev/null
+++ b/AmberTools/src/sff/dsarpack.f
@@ -0,0 +1,654 @@
+      subroutine dsarpack(n_dim,n_eig_in,n_eig_out,ncv_in,itr_in,
+     &                    eigval_tol,eigvals,eigvecs,spectrum,
+     &                    need_eigvecs,ierr,debug_arpack,
+     &                    v,workl,workd,d,resid,ax,select,
+     &                    xyz,grad,return_flag,label)
+c
+      implicit none
+c
+c     %-----------------%
+c     | Dummy Arguments |
+c     %-----------------%
+c
+      integer n_dim,n_eig_in,n_eig_out,ncv_in,itr_in,spectrum,
+     &        need_eigvecs,ierr,debug_arpack,return_flag,label
+      Double precision eigval_tol
+      Double precision eigvals(n_eig_in),eigvecs(n_dim * n_eig_in)
+      Double precision v(n_dim,ncv_in),
+     &                 workl(ncv_in*(ncv_in+8)),workd(3*n_dim),
+     &                 d(ncv_in,2),resid(n_dim),ax(n_dim),
+     &                 xyz(n_dim),grad(n_dim)
+      logical select(ncv_in)
+c
+      save
+c
+c     %---------------%
+c     | Include Files |
+c     %---------------%
+c
+c     include 'debug.h'
+c
+c\SCCS Information: @(#) 
+c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
+c
+c     %---------------------------------%
+c     | See debug.doc for documentation |
+c     %---------------------------------%
+      integer  logfil, ndigit, mgetv0,
+     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
+     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
+     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
+      common /debug/ 
+     &         logfil, ndigit, mgetv0,
+     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
+     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
+     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
+c
+c     This code shows how to use ARPACK to find a few eigenvalues 
+c     (lambda) and corresponding eigenvectors (x) for the standard 
+c     eigenvalue problem:
+c          
+c                        A*x = lambda*x
+c 
+c     where A is an n by n real symmetric matrix.
+c
+c     The main points illustrated here are 
+c
+c        1) How to declare sufficient memory to find NEV 
+c           eigenvalues of largest magnitude.  Other options
+c           are available.
+c
+c        2) Illustration of the reverse communication interface 
+c           needed to utilize the top level ARPACK routine DSAUPD 
+c           that computes the quantities needed to construct
+c           the desired eigenvalues and eigenvectors(if requested).
+c
+c        3) How to extract the desired eigenvalues and eigenvectors
+c           using the ARPACK routine DSEUPD.
+c
+c     The only thing that must be supplied in order to use this
+c     routine on your problem is to change the array dimensions 
+c     appropriately, to specify WHICH eigenvalues you want to compute 
+c     and to supply a matrix-vector product
+c
+c                         w <-  Av
+c
+c     in place of the call to AV( ) below.
+c
+c     Once usage of this routine is understood, you may wish to explore
+c     the other available options to improve convergence, to solve generalized
+c     problems, etc.  Look at the file ex-sym.doc in DOCUMENTS directory.
+c     This codes implements  
+c
+c\Example-1
+c     ... Suppose we want to solve A*x = lambda*x in regular mode,
+c         where A is derived from the central difference discretization
+c         of the 2-dimensional Laplacian on the unit square with
+c         zero Dirichlet boundary condition.
+c     ... OP = A  and  B = I.
+c     ... Assume "call av (n,x,y)" computes y = A*x
+c     ... Use mode 1 of DSAUPD.
+c
+c\BeginLib
+c
+c\Routines called:
+c     dsaupd  ARPACK reverse communication interface routine.
+c     dseupd  ARPACK routine that returns Ritz values and (optionally)
+c             Ritz vectors.
+c     dnrm2   Level 1 BLAS that computes the norm of a vector.
+c     daxpy   Level 1 BLAS that computes y <- alpha*x+y.
+c
+c\Author
+c     Richard Lehoucq
+c     Danny Sorensen
+c     Chao Yang
+c     Dept. of Computational &
+c     Applied Mathematics
+c     Rice University
+c     Houston, Texas
+c
+c\SCCS Information: %Z%
+c FILE: %M%   SID: %I%   DATE OF SID: %G%   RELEASE: %R%
+c
+c\Remarks
+c     1. None
+c
+c\EndLib
+c
+c-----------------------------------------------------------------------
+c
+c     %-------------------------------------------------------%
+c     | Storage Declarations:                                 |
+c     |                                                       |
+c     | The maximum dimensions for all arrays are             |
+c     | set here to accommodate a problem size of             |
+c     | N .le. MAXN                                           |
+c     |                                                       |
+c     | NEV is the number of eigenvalues requested.           |
+c     |     See specifications for ARPACK usage below.        |
+c     |                                                       |
+c     | NCV is the largest number of basis vectors that will  |
+c     |     be used in the Implicitly Restarted Arnoldi       |
+c     |     Process.  Work per major iteration is             |
+c     |     proportional to N*NCV*NCV.                        |
+c     |                                                       |
+c     | You must set:                                         |
+c     |                                                       |
+c     | MAXN:   Maximum dimension of the A allowed. (dynamic) |
+c     | MAXNEV: Maximum NEV allowed. (dynamic)                |
+c     | MAXNCV: Maximum NCV allowed. (dynamic)                |
+c     %-------------------------------------------------------%
+c
+C     %--------------------------------------%
+C     | F90 Allocatable Arrays (on the heap) |
+C     %--------------------------------------%
+c
+C     Double precision,allocatable,save :: v(:,:)
+C     integer,save :: v_row_allocated = 0, v_col_allocated = 0
+c
+c     %----------------------------------------------%
+c     | Originally, as F77 parameters, the following |
+c     | integers were used to dimension work arrays. |
+c     | They are replaced by dummy arguments used to |
+c     | dimension the work arrays as F90 automatic   |
+c     | arrays, but the integers are still used for  |
+c     | passing the dimensions to lower level ARPACK |
+c     | routines dsaupd, dseupd and dmout.           |
+c     %----------------------------------------------%
+c
+      integer          maxn, maxnev, maxncv, ldv
+c
+c     %-------------------------------------------%
+c     | Local F90 Automatic Arrays (on the stack) |
+c     %-------------------------------------------%
+c
+      Double precision
+C    &                 workl(ncv_in*(ncv_in+8)),
+C    &                 workd(3*n_dim), d(ncv_in,2), resid(n_dim),
+C    &                 ax(n_dim),
+     &                 cg_dstat(4)
+C     logical          select(ncv_in)
+      integer          iparam(11), ipntr(11),
+     &                 cg_istat(4)
+c
+c     %---------------%
+c     | Local Scalars |
+c     %---------------%
+c
+      character        bmat*1, which*2
+      integer          ido, n, nev, ncv, lworkl, info,
+     &                 i, j, nx, ishfts, maxitr, mode1, nconv
+      integer          L12, L18, ARPACK_ERROR, status_flag
+      data             L12, L18, ARPACK_ERROR /1, 2, -2/
+C     integer          v_row_needed, v_col_needed
+      logical          rvec
+      Double precision      
+     &                 tol, sigma
+c
+c     %------------%
+c     | Parameters |
+c     %------------%
+c
+      Double precision
+     &                 zero
+      parameter        (zero = 0.0D+0)
+c  
+c     %-----------------------------%
+c     | BLAS & LAPACK routines used |
+c     %-----------------------------%
+c
+      Double precision           
+     &                 dnrm2
+      external         dnrm2, daxpy, hessvec
+c
+c     %--------------------%
+c     | Intrinsic function |
+c     %--------------------%
+c
+      intrinsic        abs
+c
+c     %-----------------------%
+c     | Executable Statements |
+c     %-----------------------%
+c
+      if ( label.eq.0 ) go to 1
+      go to (12,18) label
+  1   continue
+c
+c     %------------------------------------------------%
+c     | Values used to calculate work array dimensions |
+c     %------------------------------------------------%
+c
+      maxn = n_dim
+      maxnev = n_eig_in
+      maxncv = ncv_in
+      ldv = maxn
+c
+c     %---------------------------------------------------%
+c     | The include debug.h statement above and           |
+c     | assignments here initiate trace output from the   |
+c     | internal actions of ARPACK.  See debug.doc in the |
+c     | DOCUMENTS directory for usage.  Initially, the    |
+c     | most useful information will be a breakdown of    |
+c     | time spent in the various stages of computation   |
+c     | given by setting msaupd = 1.                      |
+c     %---------------------------------------------------%
+c
+      ndigit = -5
+      logfil = 6
+      msgets = 0
+      msaitr = 0 
+      msapps = 0
+      if ( debug_arpack.eq.1 ) then
+        msaupd = 1
+      else
+        msaupd = 0
+      endif
+      msaup2 = 0
+      mseigt = 0
+      mseupd = 0
+c     
+c   *** Allocatable array v will be allowed to grow to its largest size;
+c   ***  it is never deallocated:
+C     v_row_needed = n_dim        !!! ldv
+C     v_col_needed = ncv_in       !!! maxncv
+C     if( allocated(v) )then
+C       if( (v_row_needed .gt. v_row_allocated)
+C    & .or. (v_col_needed .gt. v_col_allocated) )then
+C         deallocate(v,stat=ierr)
+C         if( ierr .ne. 0 )then
+C           write( logfil, '(a,i16,1x,i8)' )
+C    &       'ARPACK: could not deallocate v'
+C           go to 9000
+C         endif
+C       endif
+C     endif
+C     if( .not. allocated(v) )then
+C       allocate( v(v_row_needed,v_col_needed), stat=ierr )
+C       if( ierr .ne. 0 )then
+C         write( logfil, '(a,2i10)' )
+C    &     'ARPACK: could not allocate v'
+C         go to 9000
+C       endif
+C       v_row_allocated = v_row_needed
+C       v_col_allocated = v_col_needed
+C     endif
+C     v = zero !!! zero out entire v array
+c     
+c     %-------------------------------------------------%
+c     | The following sets dimensions for this problem. |
+c     %-------------------------------------------------%
+c
+      n = n_dim
+c
+c     %----------------------------------------------%
+c     |                                              | 
+c     | Specifications for ARPACK usage are set      | 
+c     | below:                                       |
+c     |                                              |
+c     |    1) NEV = N_EIG_IN  asks for N_EIG_IN      |  
+c     |       eigenvalues to be computed.            | 
+c     |                                              |
+c     |    2) NCV = NCV_IN sets the length of the    |
+c     |       Arnoldi factorization                  |
+c     |                                              |
+c     |    3) This is a standard problem             |
+c     |         (indicated by bmat  = 'I')           |
+c     |                                              |
+c     |    4) Ask for the NEV eigenvalues of         |
+c     |       smallest magnitude                     |
+c     |         (indicated by which = 'SM')          |
+c     |       See documentation in SSAUPD for the    |
+c     |       other options SA, LA, LM, BE.          | 
+c     |                                              |
+c     | Note: NEV and NCV must satisfy the following |
+c     | conditions:                                  |
+c     |              NEV <= MAXNEV                   |
+c     |          NEV + 1 <= NCV <= MAXNCV            |
+c     %----------------------------------------------%
+c
+      nev   = n_eig_in
+      ncv   = ncv_in 
+      bmat  = 'I'
+      if ( spectrum .eq. 1 ) then
+         which = 'SM'
+      else if ( spectrum .eq. 2 ) then
+         which = 'SA'
+      else if ( spectrum .eq. 3 ) then
+         which = 'LM'
+      else if ( spectrum .eq. 4 ) then
+         which = 'LA'
+      else if ( spectrum .eq. 5 ) then
+         which = 'BE'
+      else
+          print *, ' ERROR with _SSIMP: Spectrum .NE. (SM|SA|LA|LM|BE)'
+         go to 9000
+      end if
+c
+      if ( n .gt. maxn ) then
+         print *, ' ERROR with _SSIMP: N is greater than MAXN '
+         go to 9000
+      else if ( nev .gt. maxnev ) then
+         print *, ' ERROR with _SSIMP: NEV is greater than MAXNEV '
+         go to 9000
+      else if ( ncv .gt. maxncv ) then
+         print *, ' ERROR with _SSIMP: NCV is greater than MAXNCV '
+         go to 9000
+      end if
+c
+c     %-----------------------------------------------------%
+c     |                                                     |
+c     | Specification of stopping rules and initial         |
+c     | conditions before calling DSAUPD                    |
+c     |                                                     |
+c     | TOL  determines the stopping criterion.             |
+c     |                                                     |
+c     |      Expect                                         |
+c     |           abs(lambdaC - lambdaT) < TOL*abs(lambdaC) |
+c     |               computed   true                       |
+c     |                                                     |
+c     |      If TOL .le. 0,  then TOL <- macheps            |
+c     |           (machine precision) is used.              |
+c     |                                                     |
+c     | IDO  is the REVERSE COMMUNICATION parameter         |
+c     |      used to specify actions to be taken on return  |
+c     |      from DSAUPD. (See usage below.)                |
+c     |                                                     |
+c     |      It MUST initially be set to 0 before the first |
+c     |      call to DSAUPD.                                | 
+c     |                                                     |
+c     | INFO on entry specifies starting vector information |
+c     |      and on return indicates error codes            |
+c     |                                                     |
+c     |      Initially, setting INFO=0 indicates that a     | 
+c     |      random starting vector is requested to         |
+c     |      start the ARNOLDI iteration.  Setting INFO to  |
+c     |      a nonzero value on the initial call is used    |
+c     |      if you want to specify your own starting       |
+c     |      vector (This vector must be placed in RESID.)  | 
+c     |                                                     |
+c     | The work array WORKL is used in DSAUPD as           | 
+c     | workspace.  Its dimension LWORKL is set as          |
+c     | illustrated below.                                  |
+c     |                                                     |
+c     %-----------------------------------------------------%
+c
+      lworkl = ncv*(ncv+8)
+      tol = eigval_tol 
+      info = 0
+      ido = 0
+c
+c     %---------------------------------------------------%
+c     | Specification of Algorithm Mode:                  |
+c     |                                                   |
+c     | This program uses the exact shift strategy        |
+c     | (indicated by setting PARAM(1) = 1).              |
+c     | IPARAM(3) specifies the maximum number of Arnoldi |
+c     | iterations allowed.  Mode 1 of DSAUPD is used     |
+c     | (IPARAM(7) = 1). All these options can be changed |
+c     | by the user. For details see the documentation in |
+c     | DSAUPD.                                           |
+c     %---------------------------------------------------%
+c
+      ishfts = 1
+      maxitr = itr_in 
+      mode1 = 1
+c
+      iparam(1) = ishfts
+c                
+      iparam(3) = maxitr
+c                  
+      iparam(7) = mode1
+c
+c     %------------------------------------------------%
+c     | M A I N   L O O P (Reverse communication loop) |
+c     %------------------------------------------------%
+c
+ 10   continue
+c
+c        %---------------------------------------------%
+c        | Repeatedly call the routine DSAUPD and take | 
+c        | actions indicated by parameter IDO until    |
+c        | either convergence is indicated or maxitr   |
+c        | has been exceeded.                          |
+c        %---------------------------------------------%
+c
+         call dsaupd ( ido, bmat, n, which, nev, tol, resid, 
+     &                 ncv, v, ldv, iparam, ipntr, workd, workl,
+     &                 lworkl, info )
+c
+         if (ido .eq. -1 .or. ido .eq. 1) then
+c
+c           %--------------------------------------%
+c           | Perform matrix vector multiplication |
+c           |              y <--- OP*x             |
+c           | The user should supply his/her own   |
+c           | matrix vector multiplication routine |
+c           | here that takes workd(ipntr(1)) as   |
+c           | the input, and return the result to  |
+c           | workd(ipntr(2)).                     |
+c           %--------------------------------------%
+c
+            status_flag = 0
+ 11         continue
+               call hessvec ( n, workd(ipntr(1)), workd(ipntr(2)),
+     &                        xyz, grad, return_flag, status_flag )
+               if ( status_flag.eq.0 ) go to 13
+               if ( status_flag.lt.0 ) go to 9000
+               label = L12
+               return
+ 12         go to 11
+ 13         continue
+c
+c           %-----------------------------------------%
+c           | L O O P   B A C K to call DSAUPD again. |
+c           %-----------------------------------------%
+c
+            go to 10
+c
+         end if 
+c
+c     %----------------------------------------%
+c     | Either we have convergence or there is |
+c     | an error.                              |
+c     %----------------------------------------%
+c
+      if ( info .lt. 0 ) then
+c
+c        %--------------------------%
+c        | Error message. Check the |
+c        | documentation in DSAUPD. |
+c        %--------------------------%
+c
+         print *, ' '
+         print *, ' Error with _saupd, info = ', info
+         print *, ' Check documentation in _saupd '
+         print *, ' '
+         go to 9000
+c
+      else 
+c
+c        %-------------------------------------------%
+c        | No fatal errors occurred.                 |
+c        | Post-Process using DSEUPD.                |
+c        |                                           |
+c        | Computed eigenvalues may be extracted.    |  
+c        |                                           |
+c        | Eigenvectors may be also computed now if  |
+c        | desired.  (indicated by rvec = .true.)    | 
+c        |                                           |
+c        | The routine DSEUPD now called to do this  |
+c        | post processing (Other modes may require  |
+c        | more complicated post processing than     |
+c        | mode1.)                                   |
+c        |                                           |
+c        %-------------------------------------------%
+c           
+         if ( need_eigvecs .eq. 1 ) then
+            rvec = .true.
+         else
+            rvec = .false.
+         end if
+c
+         call dseupd ( rvec, 'All', select, d, v, ldv, sigma, 
+     &        bmat, n, which, nev, tol, resid, ncv, v, ldv, 
+     &        iparam, ipntr, workd, workl, lworkl, ierr )
+c
+c        %----------------------------------------------%
+c        | Eigenvalues are returned in the first column |
+c        | of the two dimensional array D and the       |
+c        | corresponding eigenvectors are returned in   |
+c        | the first NCONV (=IPARAM(5)) columns of the  |
+c        | two dimensional array V if requested.        |
+c        | Otherwise, an orthogonal basis for the       |
+c        | invariant subspace corresponding to the      |
+c        | eigenvalues in D is returned in V.           |
+c        %----------------------------------------------%
+c
+         if ( ierr .ne. 0) then
+c
+c           %------------------------------------%
+c           | Error condition:                   |
+c           | Check the documentation of DSEUPD. |
+c           %------------------------------------%
+c
+            print *, ' '
+            print *, ' Error with _seupd, info = ', ierr
+            print *, ' Check the documentation of _seupd. '
+            print *, ' '
+            go to 9000
+c
+         else if ( debug_arpack.eq.1 ) then
+c
+            nconv =  iparam(5)
+            n_eig_out = nconv
+            if ( nconv .le. 0 ) then
+               print *, ' '
+               print *, ' ARPACK: Not a single mode converged.'
+               print *, ' '
+               go to 9000
+            endif
+c
+C           %--------------------------------------------%
+C           | "UnDO" DO 20 j=1,nconv loop, because it is |
+C           | illegal to jump in and out from a DO loop. |
+C           %--------------------------------------------%
+c
+            j = 1
+ 16         continue
+c
+c              %---------------------------%
+c              | Compute the residual norm |
+c              |                           |
+c              |   ||  A*x - lambda*x ||   |
+c              |                           |
+c              | for the NCONV accurately  |
+c              | computed eigenvalues and  |
+c              | eigenvectors.  (iparam(5) |
+c              | indicates how many are    |
+c              | accurate to the requested |
+c              | tolerance)                |
+c              %---------------------------%
+c
+               status_flag = 0
+ 17            continue
+                  call hessvec ( n, v(1,j), ax, xyz, grad,
+     &                           return_flag, status_flag )
+                  if ( status_flag.eq.0 ) go to 19
+                  if ( status_flag.lt.0 ) go to 9000
+                  label = L18
+                  return
+ 18            go to 17
+ 19            continue
+c
+               call daxpy(n, -d(j,1), v(1,j), 1, ax, 1)
+               d(j,2) = dnrm2(n, ax, 1)
+               d(j,2) = d(j,2) / abs(d(j,1))
+c
+               j = j + 1
+               if ( j .gt. nconv ) go to 20
+c
+               go to 16
+c
+ 20         continue
+c
+c           %-----------------------------%
+c           | Display computed residuals. |
+c           %-----------------------------%
+c
+            call dmout(6, nconv, 2, d, maxncv, -6,
+     &           'Ritz values and relative residuals')
+c
+c           %-------------------------------------------%
+c           | Print additional convergence information. |
+c           %-------------------------------------------%
+c
+            if ( info .eq. 1) then
+               print *, ' '
+               print *, ' Maximum number of iterations reached.'
+               print *, ' '
+            else if ( info .eq. 3) then
+               print *, ' '
+               print *, ' No shifts could be applied during implicit',
+     &                  ' Arnoldi update, try increasing NCV.'
+               print *, ' '
+            end if
+c
+            print *, ' '
+            print *, ' _SSIMP '
+            print *, ' ====== '
+            print *, ' '
+            print *, ' Size of the matrix is ', n
+            print *, ' The number of Ritz values requested is ', nev
+            print *, ' The number of Arnoldi vectors generated',
+     &               ' (NCV) is ', ncv
+            print *, ' What portion of the spectrum: ', which
+            print *, ' The number of converged Ritz values is ',
+     &                 nconv
+            print *, ' The number of Implicit Arnoldi update',
+     &               ' iterations taken is ', iparam(3)
+            print *, ' The number of OP*x is ', iparam(9)
+            print *, ' The convergence criterion is ', tol
+            print *, ' '
+         end if
+c
+c        %----------------------------%
+c        | Return eigvals and eigvecs |
+c        %----------------------------%
+c
+         nconv =  iparam(5)
+         n_eig_out = nconv
+         if ( nconv .le. 0 ) then
+            print *, ' '
+            print *, ' ARPACK: Not a single mode converged.'
+            print *, ' '
+            go to 9000
+         endif
+c
+         do 40 j=1, nconv
+             eigvals(j) = d(j,1)
+c
+             do 30 i=1, n
+                eigvecs((j-1)*n+i) = v(i,j)
+ 30          continue
+ 40      continue
+c
+      end if
+c
+c     %--------------------------------%
+c     | Done with subroutine dsarpack. |
+c     %--------------------------------%
+c
+      label = 0
+      return
+c
+ 9000 continue !!! Error
+c
+      if( status_flag.eq.0 ) status_flag = ARPACK_ERROR
+c
+      label = status_flag
+      return
+c
+      end
+c 
+c ------------------------------------------------------------------
diff --git a/AmberTools/src/sqm/Makefile b/AmberTools/src/sqm/Makefile
index 3b49c55..61d0dc3 100644
--- a/AmberTools/src/sqm/Makefile
+++ b/AmberTools/src/sqm/Makefile
@@ -82,7 +82,7 @@ QMOBJ = qm2_allocate_e_repul.o qm2_calc_charges.o qm2_calc_dipole.o \
 install: sqm$(SFX)
 	mv sqm$(SFX) $(BINDIR)
 
-sqm$(SFX): $(SQMOBJ) $(QMOBJ) netlib sys
+sqm$(SFX): $(SQMOBJ) $(QMOBJ) sys
 	$(FC) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o sqm$(SFX) $(SQMOBJ) $(QMOBJ) \
 		-L$(LIBDIR) $(FLIBSF) ../lib/sys.a $(LDFLAGS) $(AMBERLDFLAGS)
 
@@ -101,11 +101,6 @@ $(LIBDIR)/libsqm.a: $(QMOBJ) $(LIBQMOBJ)
 sys:
 	cd ../lib; $(MAKE) sys.a
 
-netlib:
-	cd ../lapack; $(MAKE) $(LAPACK)
-	cd ../blas; $(MAKE) $(BLAS)
-	cd ../arpack && $(MAKE) install
-
 clean:
 	/bin/rm -f *.o  *.mod *.d sqm$(SFX)
 
diff --git a/AmberTools/test/Makefile b/AmberTools/test/Makefile
index 27afe24..4796250 100644
--- a/AmberTools/test/Makefile
+++ b/AmberTools/test/Makefile
@@ -3,14 +3,14 @@ include ../src/config.h
 ######    Top-level targets, for general use:    ############################
 
 test:
-	./test_at_serial.sh
+	+./test_at_serial.sh
 
 test.parallel:
 	./test_at_parallel.sh
 
 ######    Intermediate-level targets:    ############################
 
-test.serial: clean is_amberhome_defined \
+test.serial: is_amberhome_defined \
 	test.nab test.ptraj test.cpptraj test.antechamber \
 	test.leap test.resp test.pbsa test.mmpbsa test.parmed \
 	test.ambpdb test.elsize test.chamber test.sqm test.rism1d \
diff --git a/AmberTools/test/mmpbsa_py/01_Generalized_Born/energies.csv.save b/AmberTools/test/mmpbsa_py/01_Generalized_Born/energies.csv.save
index 3595375..1a0be46 100644
--- a/AmberTools/test/mmpbsa_py/01_Generalized_Born/energies.csv.save
+++ b/AmberTools/test/mmpbsa_py/01_Generalized_Born/energies.csv.save
@@ -7,16 +7,16 @@ Frame #,VDWAALS,EEL,EGB,ESURF,G gas,G solv,TOTAL
 Receptor Energy Terms
 Frame #,VDWAALS,EEL,EGB,ESURF,G gas,G solv,TOTAL
 0,-1969.4265,-17103.7958,-3027.0953,101.7772,-19073.2223,-2925.3181,-21998.5404
-1,-1956.6674,-17020.9923,-3062.954,102.3918,-18977.6597,-2960.5622,-21938.2219
+1,-1956.6674,-17020.9923,-3062.9540,102.3918,-18977.6597,-2960.5622,-21938.2219
 
 Ligand Energy Terms
 Frame #,VDWAALS,EEL,EGB,ESURF,G gas,G solv,TOTAL
-0,-1.2566,-5.6263,-28.5797,4.4486,-6.8829,-24.1311,-31.014
+0,-1.2566,-5.6263,-28.5797,4.4486,-6.8829,-24.1311,-31.0140
 1,-3.1118,-6.1548,-29.3738,4.4016,-9.2666,-24.9722,-34.2388
 
 DELTA Energy Terms
 Frame #,VDWAALS,EEL,EGB,ESURF,DELTA G gas,DELTA G solv,DELTA TOTAL
-0,-63.4582,-32.3518,35.2679,-8.3751,-95.81,26.8928,-68.9172
-1,-60.9966,-35.1045,41.6205,-8.465,-96.1011,33.1555,-62.9456
+0,-63.4582,-32.3518,35.2679,-8.3751,-95.8100,26.8928,-68.9172
+1,-60.9966,-35.1045,41.6205,-8.4650,-96.1011,33.1555,-62.9456
 
 
diff --git a/AmberTools/test/nab/Makefile b/AmberTools/test/nab/Makefile
index 1bb2505..7459a15 100644
--- a/AmberTools/test/nab/Makefile
+++ b/AmberTools/test/nab/Makefile
@@ -12,6 +12,8 @@ testrism:  \
 	rism_ion-noasymp rism_ion_pse1 rism_ion_pse3 rism_mdiis0 rism_mdiis1 \
 	rism_sp rism_sp2
 
+.NOTPARALLEL:
+
 duplex_test::
 	@./Run.duplex
 
diff --git a/AmberTools/test/nab/Run.rism_sp b/AmberTools/test/nab/Run.rism_sp
index bd8471d..a88bf58 100755
--- a/AmberTools/test/nab/Run.rism_sp
+++ b/AmberTools/test/nab/Run.rism_sp
@@ -47,7 +47,7 @@ $DO_PARALLEL $cmd --pdb ala.pdb --prmtop ala.parm7 --traj ala.nc \
                   --polarDecomp\
                   --noprogress > rism3d.snglpnt.out || error
 
-checkrism3d -err 1e-6 rism3d.snglpnt.out.check rism3d.snglpnt.out
+./checkrism3d -err 1e-6 rism3d.snglpnt.out.check rism3d.snglpnt.out
 
 awk '{if (NR % 10 == 0) print $0}' quv.1.xyzv > quv.1.xyzv.trunc
 ../dacdif -r 1e-6 quv.1.xyzv.trunc.check quv.1.xyzv.trunc
diff --git a/AmberTools/test/nab/Run.rism_sp2 b/AmberTools/test/nab/Run.rism_sp2
index a2b9521..11da8de 100755
--- a/AmberTools/test/nab/Run.rism_sp2
+++ b/AmberTools/test/nab/Run.rism_sp2
@@ -38,7 +38,7 @@ $DO_PARALLEL $cmd --pdb ala.pdb --prmtop ala.parm7 --traj ala.crd \
                   --buffer 10 --guv guv.2\
                   --noprogress > rism3d.snglpnt.2.out || error
 
-checkrism3d -err 1e-6 rism3d.snglpnt.2.out.check rism3d.snglpnt.2.out
+./checkrism3d -err 1e-6 rism3d.snglpnt.2.out.check rism3d.snglpnt.2.out
 ../dacdif -a 1e-6 guv.2.O.1.dx.check guv.2.O.1.dx
 ../dacdif -a 1e-6 guv.2.H1.2.dx.check guv.2.H1.2.dx
 ../dacdif -a 1e-6 guv.2.O.3.dx.check guv.2.O.3.dx
diff --git a/AmberTools/test/test_at_serial.sh b/AmberTools/test/test_at_serial.sh
index 15bb590..8fa52e3 100755
--- a/AmberTools/test/test_at_serial.sh
+++ b/AmberTools/test/test_at_serial.sh
@@ -39,3 +39,9 @@ fi
 
 # save summary for later reporting:
 tail -5 ${logfile} > ${logdir}/at_summary
+
+if [ "${questionable_count}" -ne 0 -o "${error_count}" -ne 0 ]
+then
+  # Tests failed
+  exit 1
+fi
diff --git a/Makefile b/Makefile
index 54ddfcb..643ba15 100644
--- a/Makefile
+++ b/Makefile
@@ -30,7 +30,7 @@ clean.test:
 test::  test.$(INSTALLTYPE)
 
 test.serial:
-	-(cd AmberTools/test && $(MAKE) test)
+	(cd AmberTools/test && $(MAKE) test)
 	-@(if [ -n "$(BUILDAMBER)" ] ; then \
 	    cd test && $(MAKE) test; \
 	    echo "" ; \
