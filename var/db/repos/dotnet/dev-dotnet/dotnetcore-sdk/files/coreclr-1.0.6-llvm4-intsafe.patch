--- a/coreclr-1.0.6/src/pal/inc/rt/intsafe.h	2017-07-01 21:44:44.431947107 +0300
+++ b/coreclr-1.0.6/src/pal/inc/rt/intsafe.h	2017-07-01 21:45:03.236947035 +0300
@@ -1449,114 +1449,4 @@
 //
 #define DWordPtrMult	ULongPtrMult
 
-//
-// size_t multiplication
-//
-#define SizeTMult		UIntPtrMult
-
-//
-// SIZE_T multiplication
-//
-#define SIZETMult		ULongPtrMult
-
-//
-// ULONGLONG multiplication
-//
-__inline
-HRESULT
-ULongLongMult(
-    IN ULONGLONG ullMultiplicand,
-    IN ULONGLONG ullMultiplier,
-    OUT ULONGLONG* pullResult)
-{
-    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
-#ifdef _AMD64_
-    ULONGLONG u64ResultHigh;
-    ULONGLONG u64ResultLow;
-    
-    *pullResult = ULONGLONG_ERROR;
-    
-    u64ResultLow = UnsignedMultiply128(ullMultiplicand, ullMultiplier, &u64ResultHigh);
-    if (u64ResultHigh == 0)
-    {
-        *pullResult = u64ResultLow;
-        hr = S_OK;
-    }
-#else
-    // 64x64 into 128 is like 32.32 x 32.32.
-    //
-    // a.b * c.d = a*(c.d) + .b*(c.d) = a*c + a*.d + .b*c + .b*.d
-    // back in non-decimal notation where A=a*2^32 and C=c*2^32:  
-    // A*C + A*d + b*C + b*d
-    // So there are four components to add together.
-    //   result = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)
-    //
-    // a * c must be 0 or there would be bits in the high 64-bits
-    // a * d must be less than 2^32 or there would be bits in the high 64-bits
-    // b * c must be less than 2^32 or there would be bits in the high 64-bits
-    // then there must be no overflow of the resulting values summed up.
-    
-    ULONG dw_a;
-    ULONG dw_b;
-    ULONG dw_c;
-    ULONG dw_d;
-    ULONGLONG ad = 0;
-    ULONGLONG bc = 0;
-    ULONGLONG bd = 0;
-    ULONGLONG ullResult = 0;
-    
-    *pullResult = ULONGLONG_ERROR;
-
-    dw_a = (ULONG)(ullMultiplicand >> 32);
-    dw_c = (ULONG)(ullMultiplier >> 32);
-
-    // common case -- if high dwords are both zero, no chance for overflow
-    if ((dw_a == 0) && (dw_c == 0))
-    {
-        dw_b = (DWORD)ullMultiplicand;
-        dw_d = (DWORD)ullMultiplier;
-
-        *pullResult = (((ULONGLONG)dw_b) * (ULONGLONG)dw_d);
-        hr = S_OK;
-    }
-    else
-    {
-        // a * c must be 0 or there would be bits set in the high 64-bits
-        if ((dw_a == 0) ||
-            (dw_c == 0))
-        {
-            dw_d = (DWORD)ullMultiplier;
-
-            // a * d must be less than 2^32 or there would be bits set in the high 64-bits
-            ad = (((ULONGLONG)dw_a) * (ULONGLONG)dw_d);
-            if ((ad & HIDWORD_MASK) == 0)
-            {
-                dw_b = (DWORD)ullMultiplicand;
-
-                // b * c must be less than 2^32 or there would be bits set in the high 64-bits
-                bc = (((ULONGLONG)dw_b) * (ULONGLONG)dw_c);
-                if ((bc & HIDWORD_MASK) == 0)
-                {
-                    // now sum them all up checking for overflow.
-                    // shifting is safe because we already checked for overflow above
-                    if (SUCCEEDED(ULongLongAdd(bc << 32, ad << 32, &ullResult)))                        
-                    {
-                        // b * d
-                        bd = (((ULONGLONG)dw_b) * (ULONGLONG)dw_d);
-                    
-                        if (SUCCEEDED(ULongLongAdd(ullResult, bd, &ullResult)))
-                        {
-                            *pullResult = ullResult;
-                            hr = S_OK;
-                        }
-                    }
-                }
-            }
-        }
-    }
-#endif // _AMD64_  
-    
-    return hr;
-}
-
 #endif // _INTSAFE_H_INCLUDED_
